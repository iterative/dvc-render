{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Dvc Render API Reference","title":"Welcome to Dvc Render"},{"location":"#welcome-to-dvc-render","text":"API Reference","title":"Welcome to Dvc Render"},{"location":"reference/dvc_render/","text":"Library for rendering DVC plots","title":"Dvc render"},{"location":"reference/dvc_render/base/","text":"Renderer Bases: abc . ABC Base Renderer class Source code in dvc_render/base.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class Renderer ( abc . ABC ): \"\"\"Base Renderer class\"\"\" DIV = \"\"\" <div id=\" {id} \"> {partial} </div> \"\"\" EXTENSIONS : Iterable [ str ] = {} def __init__ ( self , datapoints : List = None , name : str = None , ** properties ): self . datapoints = datapoints or [] self . name = name or \"\" self . properties = properties @abc . abstractmethod def partial_html ( self , ** kwargs ) -> str : \"\"\" Us this method to generate HTML content, to fill `{partial}` inside self.DIV. \"\"\" raise NotImplementedError @property @abc . abstractmethod def TYPE ( self ): # pylint: disable=missing-function-docstring raise NotImplementedError @property @abc . abstractmethod def SCRIPTS ( self ): # pylint: disable=missing-function-docstring raise NotImplementedError @staticmethod def remove_special_chars ( string : str ) -> str : \"Ensure string is valid HTML id.\" return string . translate ( { ord ( c ): \"_\" for c in r \"!@#$%^&*()[] {} ;,<>?\\/:.|`~=_+ \" } ) def generate_html ( self , html_path = None ) -> str : \"Return `DIV` formatted with `partial_html`.\" partial = self . partial_html ( html_path = html_path ) if partial : div_id = self . remove_special_chars ( self . name ) return self . DIV . format ( id = div_id , partial = partial ) return \"\" def generate_markdown ( self , report_path : Optional [ StrPath ] = None ) -> str : # pylint: disable=missing-function-docstring \"Generate a markdown element\" raise NotImplementedError @classmethod def matches ( cls , filename , properties ) -> bool : # pylint: disable=unused-argument \"Check if the Renderer is suitable.\" return Path ( filename ) . suffix in cls . EXTENSIONS generate_html ( html_path = None ) Return DIV formatted with partial_html . Source code in dvc_render/base.py 52 53 54 55 56 57 58 59 def generate_html ( self , html_path = None ) -> str : \"Return `DIV` formatted with `partial_html`.\" partial = self . partial_html ( html_path = html_path ) if partial : div_id = self . remove_special_chars ( self . name ) return self . DIV . format ( id = div_id , partial = partial ) return \"\" generate_markdown ( report_path = None ) Generate a markdown element Source code in dvc_render/base.py 61 62 63 64 65 def generate_markdown ( self , report_path : Optional [ StrPath ] = None ) -> str : # pylint: disable=missing-function-docstring \"Generate a markdown element\" raise NotImplementedError matches ( filename , properties ) classmethod Check if the Renderer is suitable. Source code in dvc_render/base.py 67 68 69 70 @classmethod def matches ( cls , filename , properties ) -> bool : # pylint: disable=unused-argument \"Check if the Renderer is suitable.\" return Path ( filename ) . suffix in cls . EXTENSIONS partial_html ( kwargs ) abstractmethod Us this method to generate HTML content, to fill {partial} inside self.DIV. Source code in dvc_render/base.py 27 28 29 30 31 32 33 @abc . abstractmethod def partial_html ( self , ** kwargs ) -> str : \"\"\" Us this method to generate HTML content, to fill `{partial}` inside self.DIV. \"\"\" raise NotImplementedError remove_special_chars ( string ) staticmethod Ensure string is valid HTML id. Source code in dvc_render/base.py 45 46 47 48 49 50 @staticmethod def remove_special_chars ( string : str ) -> str : \"Ensure string is valid HTML id.\" return string . translate ( { ord ( c ): \"_\" for c in r \"!@#$%^&*()[] {} ;,<>?\\/:.|`~=_+ \" } )","title":"Base"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer","text":"Bases: abc . ABC Base Renderer class Source code in dvc_render/base.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class Renderer ( abc . ABC ): \"\"\"Base Renderer class\"\"\" DIV = \"\"\" <div id=\" {id} \"> {partial} </div> \"\"\" EXTENSIONS : Iterable [ str ] = {} def __init__ ( self , datapoints : List = None , name : str = None , ** properties ): self . datapoints = datapoints or [] self . name = name or \"\" self . properties = properties @abc . abstractmethod def partial_html ( self , ** kwargs ) -> str : \"\"\" Us this method to generate HTML content, to fill `{partial}` inside self.DIV. \"\"\" raise NotImplementedError @property @abc . abstractmethod def TYPE ( self ): # pylint: disable=missing-function-docstring raise NotImplementedError @property @abc . abstractmethod def SCRIPTS ( self ): # pylint: disable=missing-function-docstring raise NotImplementedError @staticmethod def remove_special_chars ( string : str ) -> str : \"Ensure string is valid HTML id.\" return string . translate ( { ord ( c ): \"_\" for c in r \"!@#$%^&*()[] {} ;,<>?\\/:.|`~=_+ \" } ) def generate_html ( self , html_path = None ) -> str : \"Return `DIV` formatted with `partial_html`.\" partial = self . partial_html ( html_path = html_path ) if partial : div_id = self . remove_special_chars ( self . name ) return self . DIV . format ( id = div_id , partial = partial ) return \"\" def generate_markdown ( self , report_path : Optional [ StrPath ] = None ) -> str : # pylint: disable=missing-function-docstring \"Generate a markdown element\" raise NotImplementedError @classmethod def matches ( cls , filename , properties ) -> bool : # pylint: disable=unused-argument \"Check if the Renderer is suitable.\" return Path ( filename ) . suffix in cls . EXTENSIONS","title":"Renderer"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.generate_html","text":"Return DIV formatted with partial_html . Source code in dvc_render/base.py 52 53 54 55 56 57 58 59 def generate_html ( self , html_path = None ) -> str : \"Return `DIV` formatted with `partial_html`.\" partial = self . partial_html ( html_path = html_path ) if partial : div_id = self . remove_special_chars ( self . name ) return self . DIV . format ( id = div_id , partial = partial ) return \"\"","title":"generate_html()"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.generate_markdown","text":"Generate a markdown element Source code in dvc_render/base.py 61 62 63 64 65 def generate_markdown ( self , report_path : Optional [ StrPath ] = None ) -> str : # pylint: disable=missing-function-docstring \"Generate a markdown element\" raise NotImplementedError","title":"generate_markdown()"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.matches","text":"Check if the Renderer is suitable. Source code in dvc_render/base.py 67 68 69 70 @classmethod def matches ( cls , filename , properties ) -> bool : # pylint: disable=unused-argument \"Check if the Renderer is suitable.\" return Path ( filename ) . suffix in cls . EXTENSIONS","title":"matches()"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.partial_html","text":"Us this method to generate HTML content, to fill {partial} inside self.DIV. Source code in dvc_render/base.py 27 28 29 30 31 32 33 @abc . abstractmethod def partial_html ( self , ** kwargs ) -> str : \"\"\" Us this method to generate HTML content, to fill `{partial}` inside self.DIV. \"\"\" raise NotImplementedError","title":"partial_html()"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.remove_special_chars","text":"Ensure string is valid HTML id. Source code in dvc_render/base.py 45 46 47 48 49 50 @staticmethod def remove_special_chars ( string : str ) -> str : \"Ensure string is valid HTML id.\" return string . translate ( { ord ( c ): \"_\" for c in r \"!@#$%^&*()[] {} ;,<>?\\/:.|`~=_+ \" } )","title":"remove_special_chars()"},{"location":"reference/dvc_render/exceptions/","text":"","title":"Exceptions"},{"location":"reference/dvc_render/html/","text":"HTML Source code in dvc_render/html.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class HTML : SCRIPTS_PLACEHOLDER = \"scripts\" PLOTS_PLACEHOLDER = \"plot_divs\" PLOTS_PLACEHOLDER_FORMAT_STR = f \" {{ { PLOTS_PLACEHOLDER } }} \" REFRESH_PLACEHOLDER = \"refresh_tag\" REFRESH_TAG = '<meta http-equiv=\"refresh\" content=\" {} \">' def __init__ ( self , template : Optional [ str ] = None , refresh_seconds : Optional [ int ] = None , ): template = template or PAGE_HTML if self . PLOTS_PLACEHOLDER_FORMAT_STR not in template : raise MissingPlaceholderError ( self . PLOTS_PLACEHOLDER_FORMAT_STR ) self . template = template self . elements : List [ str ] = [] self . scripts : str = \"\" self . refresh_tag = \"\" if refresh_seconds is not None : self . refresh_tag = self . REFRESH_TAG . format ( refresh_seconds ) def with_scripts ( self , scripts : str ) -> \"HTML\" : \"Extend scripts element.\" if scripts not in self . scripts : self . scripts += f \" \\n { scripts } \" return self def with_element ( self , html : str ) -> \"HTML\" : \"Adds custom html element.\" self . elements . append ( html ) return self def embed ( self ) -> str : \"Format HTML template with all elements.\" kwargs = { self . SCRIPTS_PLACEHOLDER : self . scripts , self . PLOTS_PLACEHOLDER : \" \\n \" . join ( self . elements ), self . REFRESH_PLACEHOLDER : self . refresh_tag , } for placeholder , value in kwargs . items (): self . template = self . template . replace ( \"{\" + placeholder + \"}\" , value ) return self . template embed () Format HTML template with all elements. Source code in dvc_render/html.py 67 68 69 70 71 72 73 74 75 76 def embed ( self ) -> str : \"Format HTML template with all elements.\" kwargs = { self . SCRIPTS_PLACEHOLDER : self . scripts , self . PLOTS_PLACEHOLDER : \" \\n \" . join ( self . elements ), self . REFRESH_PLACEHOLDER : self . refresh_tag , } for placeholder , value in kwargs . items (): self . template = self . template . replace ( \"{\" + placeholder + \"}\" , value ) return self . template with_element ( html ) Adds custom html element. Source code in dvc_render/html.py 62 63 64 65 def with_element ( self , html : str ) -> \"HTML\" : \"Adds custom html element.\" self . elements . append ( html ) return self with_scripts ( scripts ) Extend scripts element. Source code in dvc_render/html.py 56 57 58 59 60 def with_scripts ( self , scripts : str ) -> \"HTML\" : \"Extend scripts element.\" if scripts not in self . scripts : self . scripts += f \" \\n { scripts } \" return self render_html ( renderers , output_file , html_template = None , refresh_seconds = None ) Use renderers to fill an HTML template and write to output_file . Source code in dvc_render/html.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def render_html ( renderers : List [ \"Renderer\" ], output_file : \"StrPath\" , html_template : Optional [ \"StrPath\" ] = None , refresh_seconds : Optional [ int ] = None , ) -> \"StrPath\" : \"Use `renderers` to fill an HTML template and write to `output_file`.\" output_path = Path ( output_file ) output_path . parent . mkdir ( exist_ok = True ) page_html : Optional [ str ] = None if html_template and Path ( html_template ) . is_file (): page_html = Path ( html_template ) . read_text ( encoding = \"utf8\" ) elif isinstance ( html_template , str ): page_html = html_template document = HTML ( page_html , refresh_seconds = refresh_seconds ) for renderer in renderers : document . with_scripts ( renderer . SCRIPTS ) document . with_element ( renderer . generate_html ( html_path = output_path )) output_path . write_text ( document . embed (), encoding = \"utf8\" ) return output_file","title":"Html"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML","text":"Source code in dvc_render/html.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 class HTML : SCRIPTS_PLACEHOLDER = \"scripts\" PLOTS_PLACEHOLDER = \"plot_divs\" PLOTS_PLACEHOLDER_FORMAT_STR = f \" {{ { PLOTS_PLACEHOLDER } }} \" REFRESH_PLACEHOLDER = \"refresh_tag\" REFRESH_TAG = '<meta http-equiv=\"refresh\" content=\" {} \">' def __init__ ( self , template : Optional [ str ] = None , refresh_seconds : Optional [ int ] = None , ): template = template or PAGE_HTML if self . PLOTS_PLACEHOLDER_FORMAT_STR not in template : raise MissingPlaceholderError ( self . PLOTS_PLACEHOLDER_FORMAT_STR ) self . template = template self . elements : List [ str ] = [] self . scripts : str = \"\" self . refresh_tag = \"\" if refresh_seconds is not None : self . refresh_tag = self . REFRESH_TAG . format ( refresh_seconds ) def with_scripts ( self , scripts : str ) -> \"HTML\" : \"Extend scripts element.\" if scripts not in self . scripts : self . scripts += f \" \\n { scripts } \" return self def with_element ( self , html : str ) -> \"HTML\" : \"Adds custom html element.\" self . elements . append ( html ) return self def embed ( self ) -> str : \"Format HTML template with all elements.\" kwargs = { self . SCRIPTS_PLACEHOLDER : self . scripts , self . PLOTS_PLACEHOLDER : \" \\n \" . join ( self . elements ), self . REFRESH_PLACEHOLDER : self . refresh_tag , } for placeholder , value in kwargs . items (): self . template = self . template . replace ( \"{\" + placeholder + \"}\" , value ) return self . template","title":"HTML"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML.embed","text":"Format HTML template with all elements. Source code in dvc_render/html.py 67 68 69 70 71 72 73 74 75 76 def embed ( self ) -> str : \"Format HTML template with all elements.\" kwargs = { self . SCRIPTS_PLACEHOLDER : self . scripts , self . PLOTS_PLACEHOLDER : \" \\n \" . join ( self . elements ), self . REFRESH_PLACEHOLDER : self . refresh_tag , } for placeholder , value in kwargs . items (): self . template = self . template . replace ( \"{\" + placeholder + \"}\" , value ) return self . template","title":"embed()"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML.with_element","text":"Adds custom html element. Source code in dvc_render/html.py 62 63 64 65 def with_element ( self , html : str ) -> \"HTML\" : \"Adds custom html element.\" self . elements . append ( html ) return self","title":"with_element()"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML.with_scripts","text":"Extend scripts element. Source code in dvc_render/html.py 56 57 58 59 60 def with_scripts ( self , scripts : str ) -> \"HTML\" : \"Extend scripts element.\" if scripts not in self . scripts : self . scripts += f \" \\n { scripts } \" return self","title":"with_scripts()"},{"location":"reference/dvc_render/html/#dvc_render.html.render_html","text":"Use renderers to fill an HTML template and write to output_file . Source code in dvc_render/html.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def render_html ( renderers : List [ \"Renderer\" ], output_file : \"StrPath\" , html_template : Optional [ \"StrPath\" ] = None , refresh_seconds : Optional [ int ] = None , ) -> \"StrPath\" : \"Use `renderers` to fill an HTML template and write to `output_file`.\" output_path = Path ( output_file ) output_path . parent . mkdir ( exist_ok = True ) page_html : Optional [ str ] = None if html_template and Path ( html_template ) . is_file (): page_html = Path ( html_template ) . read_text ( encoding = \"utf8\" ) elif isinstance ( html_template , str ): page_html = html_template document = HTML ( page_html , refresh_seconds = refresh_seconds ) for renderer in renderers : document . with_scripts ( renderer . SCRIPTS ) document . with_element ( renderer . generate_html ( html_path = output_path )) output_path . write_text ( document . embed (), encoding = \"utf8\" ) return output_file","title":"render_html()"},{"location":"reference/dvc_render/image/","text":"ImageRenderer Bases: Renderer Renderer for image plots. Source code in dvc_render/image.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class ImageRenderer ( Renderer ): \"\"\"Renderer for image plots.\"\"\" TYPE = \"image\" DIV = \"\"\" <div id=\" {id} \" style=\"border:1px solid black;text-align:center; white-space: nowrap;overflow-y:hidden;\"> {partial} </div>\"\"\" TITLE_FIELD = \"rev\" SRC_FIELD = \"src\" SCRIPTS = \"\" EXTENSIONS = { \".jpg\" , \".jpeg\" , \".gif\" , \".png\" , \".svg\" } def partial_html ( self , html_path = None , ** kwargs ) -> str : div_content = [] for datapoint in self . datapoints : src = datapoint [ self . SRC_FIELD ] if ( not src . startswith ( \"data:image;base64\" ) and os . path . isabs ( src ) and html_path ): src = os . path . relpath ( src , os . path . dirname ( html_path )) div_content . append ( f \"\"\" <div style=\"border:1px dotted black;margin:2px;display: inline-block; overflow:hidden;margin-left:8px;\"> <p> { datapoint [ self . TITLE_FIELD ] } </p> <img src=\" { src } \"> </div> \"\"\" ) if div_content : div_content . insert ( 0 , f \"<p> { self . name } </p>\" ) return \" \\n \" . join ( div_content ) return \"\" def generate_markdown ( self , report_path = None ) -> str : content = [] for datapoint in self . datapoints : src = datapoint [ self . SRC_FIELD ] if src . startswith ( \"data:image;base64\" ): raise ValueError ( \"`generate_markdown` doesn't support base64\" ) content . append ( f \" \\n ![ { datapoint [ self . TITLE_FIELD ] } ]( { src } )\" ) if content : return \" \\n \" . join ( content ) return \"\"","title":"Image"},{"location":"reference/dvc_render/image/#dvc_render.image.ImageRenderer","text":"Bases: Renderer Renderer for image plots. Source code in dvc_render/image.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class ImageRenderer ( Renderer ): \"\"\"Renderer for image plots.\"\"\" TYPE = \"image\" DIV = \"\"\" <div id=\" {id} \" style=\"border:1px solid black;text-align:center; white-space: nowrap;overflow-y:hidden;\"> {partial} </div>\"\"\" TITLE_FIELD = \"rev\" SRC_FIELD = \"src\" SCRIPTS = \"\" EXTENSIONS = { \".jpg\" , \".jpeg\" , \".gif\" , \".png\" , \".svg\" } def partial_html ( self , html_path = None , ** kwargs ) -> str : div_content = [] for datapoint in self . datapoints : src = datapoint [ self . SRC_FIELD ] if ( not src . startswith ( \"data:image;base64\" ) and os . path . isabs ( src ) and html_path ): src = os . path . relpath ( src , os . path . dirname ( html_path )) div_content . append ( f \"\"\" <div style=\"border:1px dotted black;margin:2px;display: inline-block; overflow:hidden;margin-left:8px;\"> <p> { datapoint [ self . TITLE_FIELD ] } </p> <img src=\" { src } \"> </div> \"\"\" ) if div_content : div_content . insert ( 0 , f \"<p> { self . name } </p>\" ) return \" \\n \" . join ( div_content ) return \"\" def generate_markdown ( self , report_path = None ) -> str : content = [] for datapoint in self . datapoints : src = datapoint [ self . SRC_FIELD ] if src . startswith ( \"data:image;base64\" ): raise ValueError ( \"`generate_markdown` doesn't support base64\" ) content . append ( f \" \\n ![ { datapoint [ self . TITLE_FIELD ] } ]( { src } )\" ) if content : return \" \\n \" . join ( content ) return \"\"","title":"ImageRenderer"},{"location":"reference/dvc_render/markdown/","text":"Markdown Source code in dvc_render/markdown.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Markdown : RENDERERS_PLACEHOLDER = \"renderers\" RENDERERS_PLACEHOLDER_FORMAT_STR = f \" {{ { RENDERERS_PLACEHOLDER } }} \" def __init__ ( self , template : Optional [ str ] = None , ): template = template or PAGE_MARKDOWN if self . RENDERERS_PLACEHOLDER_FORMAT_STR not in template : raise MissingPlaceholderError ( self . RENDERERS_PLACEHOLDER_FORMAT_STR , \"Markdown\" ) self . template = template self . elements : List [ str ] = [] def with_element ( self , md : str ) -> \"Markdown\" : \"Adds custom markdown element.\" self . elements . append ( md ) return self def embed ( self ) -> str : \"Format Markdown template with all elements.\" kwargs = { self . RENDERERS_PLACEHOLDER : \" \\n \" . join ( self . elements ), } for placeholder , value in kwargs . items (): self . template = self . template . replace ( \"{\" + placeholder + \"}\" , value ) return self . template embed () Format Markdown template with all elements. Source code in dvc_render/markdown.py 37 38 39 40 41 42 43 44 def embed ( self ) -> str : \"Format Markdown template with all elements.\" kwargs = { self . RENDERERS_PLACEHOLDER : \" \\n \" . join ( self . elements ), } for placeholder , value in kwargs . items (): self . template = self . template . replace ( \"{\" + placeholder + \"}\" , value ) return self . template with_element ( md ) Adds custom markdown element. Source code in dvc_render/markdown.py 32 33 34 35 def with_element ( self , md : str ) -> \"Markdown\" : \"Adds custom markdown element.\" self . elements . append ( md ) return self render_markdown ( renderers , output_file , template_path = None ) User renderers to fill an Markdown template and write to path. Source code in dvc_render/markdown.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def render_markdown ( renderers : List [ \"Renderer\" ], output_file : \"StrPath\" , template_path : Optional [ \"StrPath\" ] = None , ) -> \"StrPath\" : \"User renderers to fill an Markdown template and write to path.\" output_path = Path ( output_file ) output_path . parent . mkdir ( exist_ok = True ) page = None if template_path : with open ( template_path , encoding = \"utf-8\" ) as fobj : page = fobj . read () document = Markdown ( page ) for renderer in renderers : document . with_element ( renderer . generate_markdown ( report_path = output_path )) output_path . write_text ( document . embed (), encoding = \"utf8\" ) return output_file","title":"Markdown"},{"location":"reference/dvc_render/markdown/#dvc_render.markdown.Markdown","text":"Source code in dvc_render/markdown.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Markdown : RENDERERS_PLACEHOLDER = \"renderers\" RENDERERS_PLACEHOLDER_FORMAT_STR = f \" {{ { RENDERERS_PLACEHOLDER } }} \" def __init__ ( self , template : Optional [ str ] = None , ): template = template or PAGE_MARKDOWN if self . RENDERERS_PLACEHOLDER_FORMAT_STR not in template : raise MissingPlaceholderError ( self . RENDERERS_PLACEHOLDER_FORMAT_STR , \"Markdown\" ) self . template = template self . elements : List [ str ] = [] def with_element ( self , md : str ) -> \"Markdown\" : \"Adds custom markdown element.\" self . elements . append ( md ) return self def embed ( self ) -> str : \"Format Markdown template with all elements.\" kwargs = { self . RENDERERS_PLACEHOLDER : \" \\n \" . join ( self . elements ), } for placeholder , value in kwargs . items (): self . template = self . template . replace ( \"{\" + placeholder + \"}\" , value ) return self . template","title":"Markdown"},{"location":"reference/dvc_render/markdown/#dvc_render.markdown.Markdown.embed","text":"Format Markdown template with all elements. Source code in dvc_render/markdown.py 37 38 39 40 41 42 43 44 def embed ( self ) -> str : \"Format Markdown template with all elements.\" kwargs = { self . RENDERERS_PLACEHOLDER : \" \\n \" . join ( self . elements ), } for placeholder , value in kwargs . items (): self . template = self . template . replace ( \"{\" + placeholder + \"}\" , value ) return self . template","title":"embed()"},{"location":"reference/dvc_render/markdown/#dvc_render.markdown.Markdown.with_element","text":"Adds custom markdown element. Source code in dvc_render/markdown.py 32 33 34 35 def with_element ( self , md : str ) -> \"Markdown\" : \"Adds custom markdown element.\" self . elements . append ( md ) return self","title":"with_element()"},{"location":"reference/dvc_render/markdown/#dvc_render.markdown.render_markdown","text":"User renderers to fill an Markdown template and write to path. Source code in dvc_render/markdown.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def render_markdown ( renderers : List [ \"Renderer\" ], output_file : \"StrPath\" , template_path : Optional [ \"StrPath\" ] = None , ) -> \"StrPath\" : \"User renderers to fill an Markdown template and write to path.\" output_path = Path ( output_file ) output_path . parent . mkdir ( exist_ok = True ) page = None if template_path : with open ( template_path , encoding = \"utf-8\" ) as fobj : page = fobj . read () document = Markdown ( page ) for renderer in renderers : document . with_element ( renderer . generate_markdown ( report_path = output_path )) output_path . write_text ( document . embed (), encoding = \"utf8\" ) return output_file","title":"render_markdown()"},{"location":"reference/dvc_render/plotly/","text":"ParallelCoordinatesRenderer Bases: Renderer Renderer for Parallel Coordinates plot. Using Plotly. Source code in dvc_render/plotly.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 class ParallelCoordinatesRenderer ( Renderer ): \"\"\" Renderer for Parallel Coordinates plot. Using Plotly. \"\"\" TYPE = \"plotly\" DIV = \"\"\" <div id = \" {id} \"> <script type = \"text/javascript\"> var plotly_data = {partial} ; Plotly.newPlot(\" {id} \", plotly_data.data, plotly_data.layout); </script> </div> \"\"\" EXTENSIONS = { \".json\" } SCRIPTS = \"\"\" <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script> \"\"\" # pylint: disable=W0231 def __init__ ( self , datapoints , name = \"pcp\" , color_by : Optional [ str ] = None , fill_value : str = \"\" , ): self . datapoints = datapoints self . color_by = color_by self . name = name self . fill_value = fill_value def partial_html ( self , ** kwargs ) -> str : return json . dumps ( self . _get_plotly_data ()) def _get_plotly_data ( self ): tabular_dict = list_dict_to_dict_list ( self . datapoints ) trace : Dict [ str , Any ] = { \"type\" : \"parcoords\" , \"dimensions\" : []} for label , values in tabular_dict . items (): values = list ( map ( str , values )) is_categorical = False try : float_values = [ float ( x ) if x != self . fill_value else None for x in values ] except ValueError : is_categorical = True if is_categorical : non_missing = [ x for x in values if x != self . fill_value ] unique_values = sorted ( set ( non_missing )) unique_values . append ( self . fill_value ) dummy_values = [ unique_values . index ( x ) for x in values ] values = [ x if x != self . fill_value else \"Missing\" for x in values ] trace [ \"dimensions\" ] . append ( { \"label\" : label , \"values\" : dummy_values , \"tickvals\" : dummy_values , \"ticktext\" : values , } ) else : trace [ \"dimensions\" ] . append ({ \"label\" : label , \"values\" : float_values }) if label == self . color_by : trace [ \"line\" ] = { \"color\" : dummy_values if is_categorical else float_values , \"showscale\" : True , \"colorbar\" : { \"title\" : self . color_by }, } if is_categorical : trace [ \"line\" ][ \"colorbar\" ][ \"tickmode\" ] = \"array\" trace [ \"line\" ][ \"colorbar\" ][ \"tickvals\" ] = dummy_values trace [ \"line\" ][ \"colorbar\" ][ \"ticktext\" ] = values return { \"data\" : [ trace ], \"layout\" : {}}","title":"Plotly"},{"location":"reference/dvc_render/plotly/#dvc_render.plotly.ParallelCoordinatesRenderer","text":"Bases: Renderer Renderer for Parallel Coordinates plot. Using Plotly. Source code in dvc_render/plotly.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 class ParallelCoordinatesRenderer ( Renderer ): \"\"\" Renderer for Parallel Coordinates plot. Using Plotly. \"\"\" TYPE = \"plotly\" DIV = \"\"\" <div id = \" {id} \"> <script type = \"text/javascript\"> var plotly_data = {partial} ; Plotly.newPlot(\" {id} \", plotly_data.data, plotly_data.layout); </script> </div> \"\"\" EXTENSIONS = { \".json\" } SCRIPTS = \"\"\" <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script> \"\"\" # pylint: disable=W0231 def __init__ ( self , datapoints , name = \"pcp\" , color_by : Optional [ str ] = None , fill_value : str = \"\" , ): self . datapoints = datapoints self . color_by = color_by self . name = name self . fill_value = fill_value def partial_html ( self , ** kwargs ) -> str : return json . dumps ( self . _get_plotly_data ()) def _get_plotly_data ( self ): tabular_dict = list_dict_to_dict_list ( self . datapoints ) trace : Dict [ str , Any ] = { \"type\" : \"parcoords\" , \"dimensions\" : []} for label , values in tabular_dict . items (): values = list ( map ( str , values )) is_categorical = False try : float_values = [ float ( x ) if x != self . fill_value else None for x in values ] except ValueError : is_categorical = True if is_categorical : non_missing = [ x for x in values if x != self . fill_value ] unique_values = sorted ( set ( non_missing )) unique_values . append ( self . fill_value ) dummy_values = [ unique_values . index ( x ) for x in values ] values = [ x if x != self . fill_value else \"Missing\" for x in values ] trace [ \"dimensions\" ] . append ( { \"label\" : label , \"values\" : dummy_values , \"tickvals\" : dummy_values , \"ticktext\" : values , } ) else : trace [ \"dimensions\" ] . append ({ \"label\" : label , \"values\" : float_values }) if label == self . color_by : trace [ \"line\" ] = { \"color\" : dummy_values if is_categorical else float_values , \"showscale\" : True , \"colorbar\" : { \"title\" : self . color_by }, } if is_categorical : trace [ \"line\" ][ \"colorbar\" ][ \"tickmode\" ] = \"array\" trace [ \"line\" ][ \"colorbar\" ][ \"tickvals\" ] = dummy_values trace [ \"line\" ][ \"colorbar\" ][ \"ticktext\" ] = values return { \"data\" : [ trace ], \"layout\" : {}}","title":"ParallelCoordinatesRenderer"},{"location":"reference/dvc_render/table/","text":"TableRenderer Bases: Renderer Renderer for tables. Source code in dvc_render/table.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class TableRenderer ( Renderer ): \"\"\"Renderer for tables.\"\"\" TYPE = \"table\" DIV = \"\"\" <div id=\" {id} \" style=\"text-align: center; padding: 10x\"> <p> {id} </p> <div style=\"display: flex;justify-content: center;\"> {partial} </div> </div>\"\"\" SCRIPTS = \"\" EXTENSIONS = { \".yml\" , \".yaml\" , \".json\" } @classmethod def to_tabulate ( cls , datapoints , tablefmt ): \"\"\"Convert datapoints to tabulate format\"\"\" if tabulate is None : raise ImportError ( f \" { cls . __name__ } requires `tabulate`.\" ) data = list_dict_to_dict_list ( datapoints ) return tabulate ( data , headers = \"keys\" , tablefmt = tablefmt ) def partial_html ( self , ** kwargs ) -> str : return self . to_tabulate ( self . datapoints , tablefmt = \"html\" ) def generate_markdown ( self , report_path = None ) -> str : table = self . to_tabulate ( self . datapoints , tablefmt = \"github\" ) return f \" \\n { self . name } \\n\\n { table } \" to_tabulate ( datapoints , tablefmt ) classmethod Convert datapoints to tabulate format Source code in dvc_render/table.py 26 27 28 29 30 31 32 @classmethod def to_tabulate ( cls , datapoints , tablefmt ): \"\"\"Convert datapoints to tabulate format\"\"\" if tabulate is None : raise ImportError ( f \" { cls . __name__ } requires `tabulate`.\" ) data = list_dict_to_dict_list ( datapoints ) return tabulate ( data , headers = \"keys\" , tablefmt = tablefmt )","title":"Table"},{"location":"reference/dvc_render/table/#dvc_render.table.TableRenderer","text":"Bases: Renderer Renderer for tables. Source code in dvc_render/table.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class TableRenderer ( Renderer ): \"\"\"Renderer for tables.\"\"\" TYPE = \"table\" DIV = \"\"\" <div id=\" {id} \" style=\"text-align: center; padding: 10x\"> <p> {id} </p> <div style=\"display: flex;justify-content: center;\"> {partial} </div> </div>\"\"\" SCRIPTS = \"\" EXTENSIONS = { \".yml\" , \".yaml\" , \".json\" } @classmethod def to_tabulate ( cls , datapoints , tablefmt ): \"\"\"Convert datapoints to tabulate format\"\"\" if tabulate is None : raise ImportError ( f \" { cls . __name__ } requires `tabulate`.\" ) data = list_dict_to_dict_list ( datapoints ) return tabulate ( data , headers = \"keys\" , tablefmt = tablefmt ) def partial_html ( self , ** kwargs ) -> str : return self . to_tabulate ( self . datapoints , tablefmt = \"html\" ) def generate_markdown ( self , report_path = None ) -> str : table = self . to_tabulate ( self . datapoints , tablefmt = \"github\" ) return f \" \\n { self . name } \\n\\n { table } \"","title":"TableRenderer"},{"location":"reference/dvc_render/table/#dvc_render.table.TableRenderer.to_tabulate","text":"Convert datapoints to tabulate format Source code in dvc_render/table.py 26 27 28 29 30 31 32 @classmethod def to_tabulate ( cls , datapoints , tablefmt ): \"\"\"Convert datapoints to tabulate format\"\"\" if tabulate is None : raise ImportError ( f \" { cls . __name__ } requires `tabulate`.\" ) data = list_dict_to_dict_list ( datapoints ) return tabulate ( data , headers = \"keys\" , tablefmt = tablefmt )","title":"to_tabulate()"},{"location":"reference/dvc_render/utils/","text":"list_dict_to_dict_list ( list_dict ) Convert from list of dictionaries to dictionary of lists. Source code in dvc_render/utils.py 1 2 3 4 5 def list_dict_to_dict_list ( list_dict ): \"\"\"Convert from list of dictionaries to dictionary of lists.\"\"\" if not list_dict : return {} return { k : [ x [ k ] for x in list_dict ] for k in list_dict [ 0 ]}","title":"Utils"},{"location":"reference/dvc_render/utils/#dvc_render.utils.list_dict_to_dict_list","text":"Convert from list of dictionaries to dictionary of lists. Source code in dvc_render/utils.py 1 2 3 4 5 def list_dict_to_dict_list ( list_dict ): \"\"\"Convert from list of dictionaries to dictionary of lists.\"\"\" if not list_dict : return {} return { k : [ x [ k ] for x in list_dict ] for k in list_dict [ 0 ]}","title":"list_dict_to_dict_list()"},{"location":"reference/dvc_render/vega/","text":"VegaRenderer Bases: Renderer Renderer for vega plots. Source code in dvc_render/vega.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 class VegaRenderer ( Renderer ): \"\"\"Renderer for vega plots.\"\"\" TYPE = \"vega\" DIV = \"\"\" <div id = \" {id} \"> <script type = \"text/javascript\"> var spec = {partial} ; vegaEmbed('# {id} ', spec); </script> </div> \"\"\" SCRIPTS = \"\"\" <script src=\"https://cdn.jsdelivr.net/npm/vega@5.20.2\"></script> <script src=\"https://cdn.jsdelivr.net/npm/vega-lite@5.2.0\"></script> <script src=\"https://cdn.jsdelivr.net/npm/vega-embed@6.18.2\"></script> \"\"\" EXTENSIONS = { \".yml\" , \".yaml\" , \".json\" , \".csv\" , \".tsv\" } def __init__ ( self , datapoints : List , name : str , ** properties ): super () . __init__ ( datapoints , name , ** properties ) self . template = get_template ( self . properties . get ( \"template\" , None ), self . properties . get ( \"template_dir\" , None ), ) def get_filled_template ( self , skip_anchors : Optional [ List [ str ]] = None , strict : bool = True , as_string : bool = True , ) -> Union [ str , Dict [ str , Any ]]: \"\"\"Returns a functional vega specification\"\"\" self . template . reset () if not self . datapoints : return {} if skip_anchors is None : skip_anchors = [] if strict : if self . properties . get ( \"x\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"x\" ) ) if self . properties . get ( \"y\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"y\" ) ) self . properties . setdefault ( \"title\" , \"\" ) self . properties . setdefault ( \"x_label\" , self . properties . get ( \"x\" )) self . properties . setdefault ( \"y_label\" , self . properties . get ( \"y\" )) self . properties . setdefault ( \"data\" , self . datapoints ) names = [ \"title\" , \"x\" , \"y\" , \"x_label\" , \"y_label\" , \"data\" ] for name in names : if name in skip_anchors : continue value = self . properties . get ( name ) if value is None : continue if name == \"data\" : if not self . template . has_anchor ( name ): anchor = self . template . anchor ( name ) raise BadTemplateError ( f \"Template ' { self . template . name } ' \" f \"is not using ' { anchor } ' anchor\" ) elif name in { \"x\" , \"y\" }: value = self . template . escape_special_characters ( value ) self . template . fill_anchor ( name , value ) if as_string : return json . dumps ( self . template . content ) return self . template . content def partial_html ( self , ** kwargs ) -> str : return self . get_filled_template () # type: ignore def generate_markdown ( self , report_path = None ) -> str : if not isinstance ( self . template , LinearTemplate ): warn ( \"`generate_markdown` can only be used with `LinearTemplate`\" ) return \"\" try : from matplotlib import pyplot as plt except ImportError as e : raise ImportError ( \"matplotlib is required for `generate_markdown`\" ) from e data = list_dict_to_dict_list ( self . datapoints ) if data : report_folder = Path ( report_path ) . parent output_file = report_folder / self . name output_file = output_file . with_suffix ( \".png\" ) output_file . parent . mkdir ( exist_ok = True , parents = True ) x = self . properties . get ( \"x\" ) y = self . properties . get ( \"y\" ) data [ x ] = list ( map ( float , data [ x ])) data [ y ] = list ( map ( float , data [ y ])) plt . title ( self . properties . get ( \"title\" , output_file . stem )) plt . xlabel ( self . properties . get ( \"x_label\" , x )) plt . ylabel ( self . properties . get ( \"y_label\" , y )) plt . plot ( x , y , data = data ) plt . tight_layout () plt . savefig ( output_file ) plt . close () return f \" \\n ![ { self . name } ]( { output_file . relative_to ( report_folder ) } )\" return \"\" get_filled_template ( skip_anchors = None , strict = True , as_string = True ) Returns a functional vega specification Source code in dvc_render/vega.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def get_filled_template ( self , skip_anchors : Optional [ List [ str ]] = None , strict : bool = True , as_string : bool = True , ) -> Union [ str , Dict [ str , Any ]]: \"\"\"Returns a functional vega specification\"\"\" self . template . reset () if not self . datapoints : return {} if skip_anchors is None : skip_anchors = [] if strict : if self . properties . get ( \"x\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"x\" ) ) if self . properties . get ( \"y\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"y\" ) ) self . properties . setdefault ( \"title\" , \"\" ) self . properties . setdefault ( \"x_label\" , self . properties . get ( \"x\" )) self . properties . setdefault ( \"y_label\" , self . properties . get ( \"y\" )) self . properties . setdefault ( \"data\" , self . datapoints ) names = [ \"title\" , \"x\" , \"y\" , \"x_label\" , \"y_label\" , \"data\" ] for name in names : if name in skip_anchors : continue value = self . properties . get ( name ) if value is None : continue if name == \"data\" : if not self . template . has_anchor ( name ): anchor = self . template . anchor ( name ) raise BadTemplateError ( f \"Template ' { self . template . name } ' \" f \"is not using ' { anchor } ' anchor\" ) elif name in { \"x\" , \"y\" }: value = self . template . escape_special_characters ( value ) self . template . fill_anchor ( name , value ) if as_string : return json . dumps ( self . template . content ) return self . template . content","title":"Vega"},{"location":"reference/dvc_render/vega/#dvc_render.vega.VegaRenderer","text":"Bases: Renderer Renderer for vega plots. Source code in dvc_render/vega.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 class VegaRenderer ( Renderer ): \"\"\"Renderer for vega plots.\"\"\" TYPE = \"vega\" DIV = \"\"\" <div id = \" {id} \"> <script type = \"text/javascript\"> var spec = {partial} ; vegaEmbed('# {id} ', spec); </script> </div> \"\"\" SCRIPTS = \"\"\" <script src=\"https://cdn.jsdelivr.net/npm/vega@5.20.2\"></script> <script src=\"https://cdn.jsdelivr.net/npm/vega-lite@5.2.0\"></script> <script src=\"https://cdn.jsdelivr.net/npm/vega-embed@6.18.2\"></script> \"\"\" EXTENSIONS = { \".yml\" , \".yaml\" , \".json\" , \".csv\" , \".tsv\" } def __init__ ( self , datapoints : List , name : str , ** properties ): super () . __init__ ( datapoints , name , ** properties ) self . template = get_template ( self . properties . get ( \"template\" , None ), self . properties . get ( \"template_dir\" , None ), ) def get_filled_template ( self , skip_anchors : Optional [ List [ str ]] = None , strict : bool = True , as_string : bool = True , ) -> Union [ str , Dict [ str , Any ]]: \"\"\"Returns a functional vega specification\"\"\" self . template . reset () if not self . datapoints : return {} if skip_anchors is None : skip_anchors = [] if strict : if self . properties . get ( \"x\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"x\" ) ) if self . properties . get ( \"y\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"y\" ) ) self . properties . setdefault ( \"title\" , \"\" ) self . properties . setdefault ( \"x_label\" , self . properties . get ( \"x\" )) self . properties . setdefault ( \"y_label\" , self . properties . get ( \"y\" )) self . properties . setdefault ( \"data\" , self . datapoints ) names = [ \"title\" , \"x\" , \"y\" , \"x_label\" , \"y_label\" , \"data\" ] for name in names : if name in skip_anchors : continue value = self . properties . get ( name ) if value is None : continue if name == \"data\" : if not self . template . has_anchor ( name ): anchor = self . template . anchor ( name ) raise BadTemplateError ( f \"Template ' { self . template . name } ' \" f \"is not using ' { anchor } ' anchor\" ) elif name in { \"x\" , \"y\" }: value = self . template . escape_special_characters ( value ) self . template . fill_anchor ( name , value ) if as_string : return json . dumps ( self . template . content ) return self . template . content def partial_html ( self , ** kwargs ) -> str : return self . get_filled_template () # type: ignore def generate_markdown ( self , report_path = None ) -> str : if not isinstance ( self . template , LinearTemplate ): warn ( \"`generate_markdown` can only be used with `LinearTemplate`\" ) return \"\" try : from matplotlib import pyplot as plt except ImportError as e : raise ImportError ( \"matplotlib is required for `generate_markdown`\" ) from e data = list_dict_to_dict_list ( self . datapoints ) if data : report_folder = Path ( report_path ) . parent output_file = report_folder / self . name output_file = output_file . with_suffix ( \".png\" ) output_file . parent . mkdir ( exist_ok = True , parents = True ) x = self . properties . get ( \"x\" ) y = self . properties . get ( \"y\" ) data [ x ] = list ( map ( float , data [ x ])) data [ y ] = list ( map ( float , data [ y ])) plt . title ( self . properties . get ( \"title\" , output_file . stem )) plt . xlabel ( self . properties . get ( \"x_label\" , x )) plt . ylabel ( self . properties . get ( \"y_label\" , y )) plt . plot ( x , y , data = data ) plt . tight_layout () plt . savefig ( output_file ) plt . close () return f \" \\n ![ { self . name } ]( { output_file . relative_to ( report_folder ) } )\" return \"\"","title":"VegaRenderer"},{"location":"reference/dvc_render/vega/#dvc_render.vega.VegaRenderer.get_filled_template","text":"Returns a functional vega specification Source code in dvc_render/vega.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def get_filled_template ( self , skip_anchors : Optional [ List [ str ]] = None , strict : bool = True , as_string : bool = True , ) -> Union [ str , Dict [ str , Any ]]: \"\"\"Returns a functional vega specification\"\"\" self . template . reset () if not self . datapoints : return {} if skip_anchors is None : skip_anchors = [] if strict : if self . properties . get ( \"x\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"x\" ) ) if self . properties . get ( \"y\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"y\" ) ) self . properties . setdefault ( \"title\" , \"\" ) self . properties . setdefault ( \"x_label\" , self . properties . get ( \"x\" )) self . properties . setdefault ( \"y_label\" , self . properties . get ( \"y\" )) self . properties . setdefault ( \"data\" , self . datapoints ) names = [ \"title\" , \"x\" , \"y\" , \"x_label\" , \"y_label\" , \"data\" ] for name in names : if name in skip_anchors : continue value = self . properties . get ( name ) if value is None : continue if name == \"data\" : if not self . template . has_anchor ( name ): anchor = self . template . anchor ( name ) raise BadTemplateError ( f \"Template ' { self . template . name } ' \" f \"is not using ' { anchor } ' anchor\" ) elif name in { \"x\" , \"y\" }: value = self . template . escape_special_characters ( value ) self . template . fill_anchor ( name , value ) if as_string : return json . dumps ( self . template . content ) return self . template . content","title":"get_filled_template()"},{"location":"reference/dvc_render/vega_templates/","text":"Template Source code in dvc_render/vega_templates.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 class Template : EXTENSION = \".json\" ANCHOR = \"<DVC_METRIC_ {} >\" DEFAULT_CONTENT : Dict [ str , Any ] = {} DEFAULT_NAME : str = \"\" def __init__ ( self , content : Optional [ Dict [ str , Any ]] = None , name : Optional [ str ] = None ): if ( content and not isinstance ( content , dict ) or self . DEFAULT_CONTENT and not isinstance ( self . DEFAULT_CONTENT , dict ) ): raise BadTemplateError () self . _original_content = content or self . DEFAULT_CONTENT self . content : Dict [ str , Any ] = self . _original_content self . name = name or self . DEFAULT_NAME self . filename = Path ( self . name ) . with_suffix ( self . EXTENSION ) @classmethod def anchor ( cls , name ): \"Get ANCHOR formatted with name.\" return cls . ANCHOR . format ( name . upper ()) @classmethod def escape_special_characters ( cls , value : str ) -> str : \"Escape special characters in `value`\" for character in ( \".\" , \"[\" , \"]\" ): value = value . replace ( character , \" \\\\ \" + character ) return value @staticmethod def check_field_exists ( data , field ): \"Raise NoFieldInDataError if `field` not in `data`.\" if not any ( field in row for row in data ): raise NoFieldInDataError ( field ) def reset ( self ): \"\"\"Reset self.content to its original state.\"\"\" self . content = self . _original_content def has_anchor ( self , name ) -> bool : \"Check if ANCHOR formatted with name is in content.\" found = dict_find_value ( self . content , self . anchor ( name )) return found def fill_anchor ( self , name , value ) -> None : \"Replace anchor `name` with `value` in content.\" self . content = dict_replace_value ( self . content , self . anchor ( name ), value ) anchor ( name ) classmethod Get ANCHOR formatted with name. Source code in dvc_render/vega_templates.py 96 97 98 99 @classmethod def anchor ( cls , name ): \"Get ANCHOR formatted with name.\" return cls . ANCHOR . format ( name . upper ()) check_field_exists ( data , field ) staticmethod Raise NoFieldInDataError if field not in data . Source code in dvc_render/vega_templates.py 108 109 110 111 112 @staticmethod def check_field_exists ( data , field ): \"Raise NoFieldInDataError if `field` not in `data`.\" if not any ( field in row for row in data ): raise NoFieldInDataError ( field ) escape_special_characters ( value ) classmethod Escape special characters in value Source code in dvc_render/vega_templates.py 101 102 103 104 105 106 @classmethod def escape_special_characters ( cls , value : str ) -> str : \"Escape special characters in `value`\" for character in ( \".\" , \"[\" , \"]\" ): value = value . replace ( character , \" \\\\ \" + character ) return value fill_anchor ( name , value ) Replace anchor name with value in content. Source code in dvc_render/vega_templates.py 123 124 125 def fill_anchor ( self , name , value ) -> None : \"Replace anchor `name` with `value` in content.\" self . content = dict_replace_value ( self . content , self . anchor ( name ), value ) has_anchor ( name ) Check if ANCHOR formatted with name is in content. Source code in dvc_render/vega_templates.py 118 119 120 121 def has_anchor ( self , name ) -> bool : \"Check if ANCHOR formatted with name is in content.\" found = dict_find_value ( self . content , self . anchor ( name )) return found reset () Reset self.content to its original state. Source code in dvc_render/vega_templates.py 114 115 116 def reset ( self ): \"\"\"Reset self.content to its original state.\"\"\" self . content = self . _original_content dump_templates ( output , targets = None ) Write TEMPLATES in .json format to output . Source code in dvc_render/vega_templates.py 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 def dump_templates ( output : \"StrPath\" , targets : Optional [ List ] = None ) -> None : \"Write TEMPLATES in `.json` format to `output`.\" output = Path ( output ) output . mkdir ( exist_ok = True ) if targets : templates = [ template for template in TEMPLATES if template . DEFAULT_NAME in targets ] else : templates = TEMPLATES for template_cls in templates : template = template_cls () path = output / template . filename if path . exists (): content = path . read_text ( encoding = \"utf-8\" ) if content != template . content : raise TemplateContentDoesNotMatch ( template . DEFAULT_NAME , str ( path )) else : path . write_text ( json . dumps ( template . content ), encoding = \"utf-8\" ) get_template ( template = None , template_dir = None , fs = None ) Return template instance based on given template arg. If template is already an instance, return it. If template is None, return default linear template. If template is a path, will try to find it: - Inside template_dir - As a relative path to cwd. If template matches one of the DEFAULT_NAMEs in TEMPLATES, return an instance of the one matching. Source code in dvc_render/vega_templates.py 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 def get_template ( template : Union [ Optional [ str ], Template ] = None , template_dir : Optional [ str ] = None , fs = None , ) -> Template : \"\"\"Return template instance based on given template arg. If template is already an instance, return it. If template is None, return default `linear` template. If template is a path, will try to find it: - Inside `template_dir` - As a relative path to cwd. If template matches one of the DEFAULT_NAMEs in TEMPLATES, return an instance of the one matching. \"\"\" if isinstance ( template , Template ): return template if template is None : template = \"linear\" template_path = _find_template ( template , template_dir , fs ) _open = open if fs is None else fs . open if template_path : with _open ( template_path , encoding = \"utf-8\" ) as f : content = json . load ( f ) return Template ( content , name = template ) for template_cls in TEMPLATES : if template_cls . DEFAULT_NAME == template : return template_cls () raise TemplateNotFoundError ( template )","title":"Vega templates"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template","text":"Source code in dvc_render/vega_templates.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 class Template : EXTENSION = \".json\" ANCHOR = \"<DVC_METRIC_ {} >\" DEFAULT_CONTENT : Dict [ str , Any ] = {} DEFAULT_NAME : str = \"\" def __init__ ( self , content : Optional [ Dict [ str , Any ]] = None , name : Optional [ str ] = None ): if ( content and not isinstance ( content , dict ) or self . DEFAULT_CONTENT and not isinstance ( self . DEFAULT_CONTENT , dict ) ): raise BadTemplateError () self . _original_content = content or self . DEFAULT_CONTENT self . content : Dict [ str , Any ] = self . _original_content self . name = name or self . DEFAULT_NAME self . filename = Path ( self . name ) . with_suffix ( self . EXTENSION ) @classmethod def anchor ( cls , name ): \"Get ANCHOR formatted with name.\" return cls . ANCHOR . format ( name . upper ()) @classmethod def escape_special_characters ( cls , value : str ) -> str : \"Escape special characters in `value`\" for character in ( \".\" , \"[\" , \"]\" ): value = value . replace ( character , \" \\\\ \" + character ) return value @staticmethod def check_field_exists ( data , field ): \"Raise NoFieldInDataError if `field` not in `data`.\" if not any ( field in row for row in data ): raise NoFieldInDataError ( field ) def reset ( self ): \"\"\"Reset self.content to its original state.\"\"\" self . content = self . _original_content def has_anchor ( self , name ) -> bool : \"Check if ANCHOR formatted with name is in content.\" found = dict_find_value ( self . content , self . anchor ( name )) return found def fill_anchor ( self , name , value ) -> None : \"Replace anchor `name` with `value` in content.\" self . content = dict_replace_value ( self . content , self . anchor ( name ), value )","title":"Template"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.anchor","text":"Get ANCHOR formatted with name. Source code in dvc_render/vega_templates.py 96 97 98 99 @classmethod def anchor ( cls , name ): \"Get ANCHOR formatted with name.\" return cls . ANCHOR . format ( name . upper ())","title":"anchor()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.check_field_exists","text":"Raise NoFieldInDataError if field not in data . Source code in dvc_render/vega_templates.py 108 109 110 111 112 @staticmethod def check_field_exists ( data , field ): \"Raise NoFieldInDataError if `field` not in `data`.\" if not any ( field in row for row in data ): raise NoFieldInDataError ( field )","title":"check_field_exists()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.escape_special_characters","text":"Escape special characters in value Source code in dvc_render/vega_templates.py 101 102 103 104 105 106 @classmethod def escape_special_characters ( cls , value : str ) -> str : \"Escape special characters in `value`\" for character in ( \".\" , \"[\" , \"]\" ): value = value . replace ( character , \" \\\\ \" + character ) return value","title":"escape_special_characters()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.fill_anchor","text":"Replace anchor name with value in content. Source code in dvc_render/vega_templates.py 123 124 125 def fill_anchor ( self , name , value ) -> None : \"Replace anchor `name` with `value` in content.\" self . content = dict_replace_value ( self . content , self . anchor ( name ), value )","title":"fill_anchor()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.has_anchor","text":"Check if ANCHOR formatted with name is in content. Source code in dvc_render/vega_templates.py 118 119 120 121 def has_anchor ( self , name ) -> bool : \"Check if ANCHOR formatted with name is in content.\" found = dict_find_value ( self . content , self . anchor ( name )) return found","title":"has_anchor()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.reset","text":"Reset self.content to its original state. Source code in dvc_render/vega_templates.py 114 115 116 def reset ( self ): \"\"\"Reset self.content to its original state.\"\"\" self . content = self . _original_content","title":"reset()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.dump_templates","text":"Write TEMPLATES in .json format to output . Source code in dvc_render/vega_templates.py 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 def dump_templates ( output : \"StrPath\" , targets : Optional [ List ] = None ) -> None : \"Write TEMPLATES in `.json` format to `output`.\" output = Path ( output ) output . mkdir ( exist_ok = True ) if targets : templates = [ template for template in TEMPLATES if template . DEFAULT_NAME in targets ] else : templates = TEMPLATES for template_cls in templates : template = template_cls () path = output / template . filename if path . exists (): content = path . read_text ( encoding = \"utf-8\" ) if content != template . content : raise TemplateContentDoesNotMatch ( template . DEFAULT_NAME , str ( path )) else : path . write_text ( json . dumps ( template . content ), encoding = \"utf-8\" )","title":"dump_templates()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.get_template","text":"Return template instance based on given template arg. If template is already an instance, return it. If template is None, return default linear template. If template is a path, will try to find it: - Inside template_dir - As a relative path to cwd. If template matches one of the DEFAULT_NAMEs in TEMPLATES, return an instance of the one matching. Source code in dvc_render/vega_templates.py 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 def get_template ( template : Union [ Optional [ str ], Template ] = None , template_dir : Optional [ str ] = None , fs = None , ) -> Template : \"\"\"Return template instance based on given template arg. If template is already an instance, return it. If template is None, return default `linear` template. If template is a path, will try to find it: - Inside `template_dir` - As a relative path to cwd. If template matches one of the DEFAULT_NAMEs in TEMPLATES, return an instance of the one matching. \"\"\" if isinstance ( template , Template ): return template if template is None : template = \"linear\" template_path = _find_template ( template , template_dir , fs ) _open = open if fs is None else fs . open if template_path : with _open ( template_path , encoding = \"utf-8\" ) as f : content = json . load ( f ) return Template ( content , name = template ) for template_cls in TEMPLATES : if template_cls . DEFAULT_NAME == template : return template_cls () raise TemplateNotFoundError ( template )","title":"get_template()"}]}