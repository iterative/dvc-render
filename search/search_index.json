{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Dvc Render","text":"<ul> <li>API Reference</li> </ul>"},{"location":"reference/dvc_render/","title":"Dvc render","text":"<p>Library for rendering DVC plots</p>"},{"location":"reference/dvc_render/base/","title":"Base","text":""},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer","title":"<code>Renderer</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base Renderer class</p> Source code in <code>dvc_render/base.py</code> <pre><code>class Renderer(abc.ABC):\n    \"\"\"Base Renderer class\"\"\"\n\n    DIV = \"\"\"\n    &lt;div id=\"{id}\"&gt;\n      {partial}\n    &lt;/div&gt;\n    \"\"\"\n\n    EXTENSIONS: Iterable[str] = {}\n\n    def __init__(\n        self,\n        datapoints: Optional[list] = None,\n        name: Optional[str] = None,\n        **properties,\n    ):\n        self.datapoints = datapoints or []\n        self.name = name or \"\"\n        self.properties = properties\n\n    @abc.abstractmethod\n    def partial_html(self, **kwargs) -&gt; str:\n        \"\"\"\n        Us this method to generate HTML content,\n        to fill `{partial}` inside self.DIV.\n        \"\"\"\n        raise NotImplementedError\n\n    @property\n    @abc.abstractmethod\n    def TYPE(self):  # noqa: N802\n        raise NotImplementedError\n\n    @property\n    @abc.abstractmethod\n    def SCRIPTS(self):  # noqa: N802\n        raise NotImplementedError\n\n    @staticmethod\n    def remove_special_chars(string: str) -&gt; str:\n        \"Ensure string is valid HTML id.\"\n        return string.translate(\n            {ord(c): \"_\" for c in r\"!@#$%^&amp;*()[]{};,&lt;&gt;?\\/:.|`~=_+ \"}\n        )\n\n    def generate_html(self, html_path=None) -&gt; str:\n        \"Return `DIV` formatted with `partial_html`.\"\n        partial = self.partial_html(html_path=html_path)\n        if partial:\n            div_id = self.remove_special_chars(self.name)\n\n            return self.DIV.format(id=div_id, partial=partial)\n        return \"\"\n\n    def generate_markdown(self, report_path: Optional[StrPath] = None) -&gt; str:  # pylint: disable=missing-function-docstring\n        \"Generate a markdown element\"\n        raise NotImplementedError\n\n    @classmethod\n    def matches(cls, filename, properties=None) -&gt; bool:  # noqa: ARG003\n        \"Check if the Renderer is suitable.\"\n        return Path(filename).suffix in cls.EXTENSIONS\n</code></pre>"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.generate_html","title":"<code>generate_html(html_path=None)</code>","text":"<p>Return <code>DIV</code> formatted with <code>partial_html</code>.</p> Source code in <code>dvc_render/base.py</code> <pre><code>def generate_html(self, html_path=None) -&gt; str:\n    \"Return `DIV` formatted with `partial_html`.\"\n    partial = self.partial_html(html_path=html_path)\n    if partial:\n        div_id = self.remove_special_chars(self.name)\n\n        return self.DIV.format(id=div_id, partial=partial)\n    return \"\"\n</code></pre>"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.generate_markdown","title":"<code>generate_markdown(report_path=None)</code>","text":"<p>Generate a markdown element</p> Source code in <code>dvc_render/base.py</code> <pre><code>def generate_markdown(self, report_path: Optional[StrPath] = None) -&gt; str:  # pylint: disable=missing-function-docstring\n    \"Generate a markdown element\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.matches","title":"<code>matches(filename, properties=None)</code>  <code>classmethod</code>","text":"<p>Check if the Renderer is suitable.</p> Source code in <code>dvc_render/base.py</code> <pre><code>@classmethod\ndef matches(cls, filename, properties=None) -&gt; bool:  # noqa: ARG003\n    \"Check if the Renderer is suitable.\"\n    return Path(filename).suffix in cls.EXTENSIONS\n</code></pre>"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.partial_html","title":"<code>partial_html(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Us this method to generate HTML content, to fill <code>{partial}</code> inside self.DIV.</p> Source code in <code>dvc_render/base.py</code> <pre><code>@abc.abstractmethod\ndef partial_html(self, **kwargs) -&gt; str:\n    \"\"\"\n    Us this method to generate HTML content,\n    to fill `{partial}` inside self.DIV.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.remove_special_chars","title":"<code>remove_special_chars(string)</code>  <code>staticmethod</code>","text":"<p>Ensure string is valid HTML id.</p> Source code in <code>dvc_render/base.py</code> <pre><code>@staticmethod\ndef remove_special_chars(string: str) -&gt; str:\n    \"Ensure string is valid HTML id.\"\n    return string.translate(\n        {ord(c): \"_\" for c in r\"!@#$%^&amp;*()[]{};,&lt;&gt;?\\/:.|`~=_+ \"}\n    )\n</code></pre>"},{"location":"reference/dvc_render/exceptions/","title":"Exceptions","text":""},{"location":"reference/dvc_render/html/","title":"Html","text":""},{"location":"reference/dvc_render/html/#dvc_render.html.HTML","title":"<code>HTML</code>","text":"Source code in <code>dvc_render/html.py</code> <pre><code>class HTML:\n    SCRIPTS_PLACEHOLDER = \"scripts\"\n    PLOTS_PLACEHOLDER = \"plot_divs\"\n    PLOTS_PLACEHOLDER_FORMAT_STR = f\"{{{PLOTS_PLACEHOLDER}}}\"\n    REFRESH_PLACEHOLDER = \"refresh_tag\"\n    REFRESH_TAG = '&lt;meta http-equiv=\"refresh\" content=\"{}\"&gt;'\n\n    def __init__(\n        self,\n        template: Optional[str] = None,\n        refresh_seconds: Optional[int] = None,\n    ):\n        template = template or PAGE_HTML\n        if self.PLOTS_PLACEHOLDER_FORMAT_STR not in template:\n            raise MissingPlaceholderError(self.PLOTS_PLACEHOLDER_FORMAT_STR)\n\n        self.template = template\n        self.elements: list[str] = []\n        self.scripts: str = \"\"\n        self.refresh_tag = \"\"\n        if refresh_seconds is not None:\n            self.refresh_tag = self.REFRESH_TAG.format(refresh_seconds)\n\n    def with_scripts(self, scripts: str) -&gt; \"HTML\":\n        \"Extend scripts element.\"\n        if scripts not in self.scripts:\n            self.scripts += f\"\\n{scripts}\"\n        return self\n\n    def with_element(self, html: str) -&gt; \"HTML\":\n        \"Adds custom html element.\"\n        self.elements.append(html)\n        return self\n\n    def embed(self) -&gt; str:\n        \"Format HTML template with all elements.\"\n        kwargs = {\n            self.SCRIPTS_PLACEHOLDER: self.scripts,\n            self.PLOTS_PLACEHOLDER: \"\\n\".join(self.elements),\n            self.REFRESH_PLACEHOLDER: self.refresh_tag,\n        }\n        for placeholder, value in kwargs.items():\n            self.template = self.template.replace(\"{\" + placeholder + \"}\", value)\n        return self.template\n</code></pre>"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML.embed","title":"<code>embed()</code>","text":"<p>Format HTML template with all elements.</p> Source code in <code>dvc_render/html.py</code> <pre><code>def embed(self) -&gt; str:\n    \"Format HTML template with all elements.\"\n    kwargs = {\n        self.SCRIPTS_PLACEHOLDER: self.scripts,\n        self.PLOTS_PLACEHOLDER: \"\\n\".join(self.elements),\n        self.REFRESH_PLACEHOLDER: self.refresh_tag,\n    }\n    for placeholder, value in kwargs.items():\n        self.template = self.template.replace(\"{\" + placeholder + \"}\", value)\n    return self.template\n</code></pre>"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML.with_element","title":"<code>with_element(html)</code>","text":"<p>Adds custom html element.</p> Source code in <code>dvc_render/html.py</code> <pre><code>def with_element(self, html: str) -&gt; \"HTML\":\n    \"Adds custom html element.\"\n    self.elements.append(html)\n    return self\n</code></pre>"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML.with_scripts","title":"<code>with_scripts(scripts)</code>","text":"<p>Extend scripts element.</p> Source code in <code>dvc_render/html.py</code> <pre><code>def with_scripts(self, scripts: str) -&gt; \"HTML\":\n    \"Extend scripts element.\"\n    if scripts not in self.scripts:\n        self.scripts += f\"\\n{scripts}\"\n    return self\n</code></pre>"},{"location":"reference/dvc_render/html/#dvc_render.html.render_html","title":"<code>render_html(renderers, output_file, html_template=None, refresh_seconds=None)</code>","text":"<p>Use <code>renderers</code> to fill an HTML template and write to <code>output_file</code>.</p> Source code in <code>dvc_render/html.py</code> <pre><code>def render_html(\n    renderers: list[\"Renderer\"],\n    output_file: \"StrPath\",\n    html_template: Optional[\"StrPath\"] = None,\n    refresh_seconds: Optional[int] = None,\n) -&gt; \"StrPath\":\n    \"Use `renderers` to fill an HTML template and write to `output_file`.\"\n    output_path = Path(output_file)\n    output_path.parent.mkdir(exist_ok=True)\n\n    page_html: Optional[str] = None\n    if html_template and Path(html_template).is_file():\n        page_html = Path(html_template).read_text(encoding=\"utf8\")\n    elif isinstance(html_template, str):\n        page_html = html_template\n\n    document = HTML(page_html, refresh_seconds=refresh_seconds)\n\n    sorted_renderers = sorted(\n        renderers,\n        key=_order_image_per_step,\n    )\n\n    for renderer in sorted_renderers:\n        document.with_scripts(renderer.SCRIPTS)\n        document.with_element(renderer.generate_html(html_path=output_path))\n\n    output_path.write_text(document.embed(), encoding=\"utf8\")\n\n    return output_file\n</code></pre>"},{"location":"reference/dvc_render/image/","title":"Image","text":""},{"location":"reference/dvc_render/image/#dvc_render.image.ImageRenderer","title":"<code>ImageRenderer</code>","text":"<p>               Bases: <code>Renderer</code></p> <p>Renderer for image plots.</p> Source code in <code>dvc_render/image.py</code> <pre><code>class ImageRenderer(Renderer):\n    \"\"\"Renderer for image plots.\"\"\"\n\n    TYPE = \"image\"\n    DIV = \"\"\"\n        &lt;div\n            id=\"{id}\"\n            style=\"border:1px solid black;text-align:center;\n            white-space: nowrap;overflow-y:hidden;\"&gt;\n            {partial}\n        &lt;/div&gt;\"\"\"\n\n    TITLE_FIELD = \"rev\"\n    SRC_FIELD = \"src\"\n\n    SCRIPTS = \"\"\n\n    EXTENSIONS = {\".jpg\", \".jpeg\", \".gif\", \".png\", \".svg\"}\n\n    def partial_html(self, html_path=None, **kwargs) -&gt; str:  # noqa: ARG002\n        div_content = []\n        for datapoint in self.datapoints:\n            src = datapoint[self.SRC_FIELD]\n\n            if (\n                not src.startswith(\"data:image;base64\")\n                and os.path.isabs(src)\n                and html_path\n            ):\n                src = os.path.relpath(src, os.path.dirname(html_path))\n\n            div_content.append(\n                f\"\"\"\n                &lt;div\n                    style=\"border:1px dotted black;margin:2px;display:\n                    inline-block;\n                    overflow:hidden;margin-left:8px;\"&gt;\n                    &lt;p&gt;{datapoint[self.TITLE_FIELD]}&lt;/p&gt;\n                    &lt;img src=\"{src}\"&gt;\n                &lt;/div&gt;\n                \"\"\"\n            )\n        if div_content:\n            div_content.insert(0, f\"&lt;p&gt;{self.name}&lt;/p&gt;\")\n            return \"\\n\".join(div_content)\n        return \"\"\n\n    def generate_markdown(self, report_path=None) -&gt; str:  # noqa: ARG002\n        content = []\n        for datapoint in self.datapoints:\n            src = datapoint[self.SRC_FIELD]\n            if src.startswith(\"data:image;base64\"):\n                src = src.replace(\"data:image;base64\", \"data:image/png;base64\")\n            content.append(f\"\\n![{datapoint[self.TITLE_FIELD]}]({src})\")\n        if content:\n            return \"\\n\".join(content)\n        return \"\"\n</code></pre>"},{"location":"reference/dvc_render/markdown/","title":"Markdown","text":""},{"location":"reference/dvc_render/markdown/#dvc_render.markdown.Markdown","title":"<code>Markdown</code>","text":"Source code in <code>dvc_render/markdown.py</code> <pre><code>class Markdown:\n    RENDERERS_PLACEHOLDER = \"renderers\"\n    RENDERERS_PLACEHOLDER_FORMAT_STR = f\"{{{RENDERERS_PLACEHOLDER}}}\"\n\n    def __init__(\n        self,\n        template: Optional[str] = None,\n    ):\n        template = template or PAGE_MARKDOWN\n        if self.RENDERERS_PLACEHOLDER_FORMAT_STR not in template:\n            raise MissingPlaceholderError(\n                self.RENDERERS_PLACEHOLDER_FORMAT_STR, \"Markdown\"\n            )\n\n        self.template = template\n        self.elements: list[str] = []\n\n    def with_element(self, md: str) -&gt; \"Markdown\":\n        \"Adds custom markdown element.\"\n        self.elements.append(md)\n        return self\n\n    def embed(self) -&gt; str:\n        \"Format Markdown template with all elements.\"\n        kwargs = {\n            self.RENDERERS_PLACEHOLDER: \"\\n\".join(self.elements),\n        }\n        for placeholder, value in kwargs.items():\n            self.template = self.template.replace(\"{\" + placeholder + \"}\", value)\n        return self.template\n</code></pre>"},{"location":"reference/dvc_render/markdown/#dvc_render.markdown.Markdown.embed","title":"<code>embed()</code>","text":"<p>Format Markdown template with all elements.</p> Source code in <code>dvc_render/markdown.py</code> <pre><code>def embed(self) -&gt; str:\n    \"Format Markdown template with all elements.\"\n    kwargs = {\n        self.RENDERERS_PLACEHOLDER: \"\\n\".join(self.elements),\n    }\n    for placeholder, value in kwargs.items():\n        self.template = self.template.replace(\"{\" + placeholder + \"}\", value)\n    return self.template\n</code></pre>"},{"location":"reference/dvc_render/markdown/#dvc_render.markdown.Markdown.with_element","title":"<code>with_element(md)</code>","text":"<p>Adds custom markdown element.</p> Source code in <code>dvc_render/markdown.py</code> <pre><code>def with_element(self, md: str) -&gt; \"Markdown\":\n    \"Adds custom markdown element.\"\n    self.elements.append(md)\n    return self\n</code></pre>"},{"location":"reference/dvc_render/markdown/#dvc_render.markdown.render_markdown","title":"<code>render_markdown(renderers, output_file=None, template_path=None)</code>","text":"<p>User renderers to fill an Markdown template and write to path.</p> Source code in <code>dvc_render/markdown.py</code> <pre><code>def render_markdown(\n    renderers: list[\"Renderer\"],\n    output_file: Optional[\"StrPath\"] = None,\n    template_path: Optional[\"StrPath\"] = None,\n) -&gt; \"StrPath\":\n    \"User renderers to fill an Markdown template and write to path.\"\n    output_path = None\n    if output_file:\n        output_path = Path(output_file)\n        output_path.parent.mkdir(exist_ok=True)\n\n    page = None\n    if template_path:\n        with open(template_path, encoding=\"utf-8\") as fobj:\n            page = fobj.read()\n\n    document = Markdown(page)\n\n    for renderer in renderers:\n        document.with_element(renderer.generate_markdown(report_path=output_path))\n\n    if output_file and output_path:\n        output_path.write_text(document.embed(), encoding=\"utf8\")\n\n        return output_file\n\n    return document.embed()\n</code></pre>"},{"location":"reference/dvc_render/plotly/","title":"Plotly","text":""},{"location":"reference/dvc_render/plotly/#dvc_render.plotly.ParallelCoordinatesRenderer","title":"<code>ParallelCoordinatesRenderer</code>","text":"<p>               Bases: <code>Renderer</code></p> <p>Renderer for Parallel Coordinates plot.</p> <p>Using Plotly.</p> Source code in <code>dvc_render/plotly.py</code> <pre><code>class ParallelCoordinatesRenderer(Renderer):\n    \"\"\"\n    Renderer for Parallel Coordinates plot.\n\n    Using Plotly.\n    \"\"\"\n\n    TYPE = \"plotly\"\n\n    DIV = \"\"\"\n    &lt;div id = \"{id}\"&gt;\n        &lt;script type = \"text/javascript\"&gt;\n            var plotly_data = {partial};\n            Plotly.newPlot(\"{id}\", plotly_data.data, plotly_data.layout);\n        &lt;/script&gt;\n    &lt;/div&gt;\n    \"\"\"\n\n    EXTENSIONS = {\".json\"}\n\n    SCRIPTS = \"\"\"\n    &lt;script src=\"https://cdn.plot.ly/plotly-latest.min.js\"&gt;&lt;/script&gt;\n    \"\"\"\n\n    # pylint: disable=W0231\n    def __init__(\n        self,\n        datapoints,\n        name=\"pcp\",\n        color_by: Optional[str] = None,\n        fill_value: str = \"\",\n    ):\n        self.datapoints = datapoints\n        self.color_by = color_by\n        self.name = name\n        self.fill_value = fill_value\n\n    def partial_html(self, **kwargs) -&gt; str:  # noqa: ARG002\n        return json.dumps(self._get_plotly_data())\n\n    def _get_plotly_data(self):\n        tabular_dict = list_dict_to_dict_list(self.datapoints)\n\n        trace: dict[str, Any] = {\"type\": \"parcoords\", \"dimensions\": []}\n        for label, values in tabular_dict.items():\n            values = list(map(str, values))\n            is_categorical = False\n            try:\n                float_values = [\n                    float(x) if x != self.fill_value else None for x in values\n                ]\n            except ValueError:\n                is_categorical = True\n\n            if is_categorical:\n                non_missing = [x for x in values if x != self.fill_value]\n                unique_values = sorted(set(non_missing))\n                unique_values.append(self.fill_value)\n\n                dummy_values = [unique_values.index(x) for x in values]\n\n                values = [x if x != self.fill_value else \"Missing\" for x in values]\n                trace[\"dimensions\"].append(\n                    {\n                        \"label\": label,\n                        \"values\": dummy_values,\n                        \"tickvals\": dummy_values,\n                        \"ticktext\": values,\n                    }\n                )\n            else:\n                trace[\"dimensions\"].append({\"label\": label, \"values\": float_values})\n\n            if label == self.color_by:\n                trace[\"line\"] = {\n                    \"color\": dummy_values if is_categorical else float_values,\n                    \"showscale\": True,\n                    \"colorbar\": {\"title\": self.color_by},\n                }\n                if is_categorical:\n                    trace[\"line\"][\"colorbar\"][\"tickmode\"] = \"array\"\n                    trace[\"line\"][\"colorbar\"][\"tickvals\"] = dummy_values\n                    trace[\"line\"][\"colorbar\"][\"ticktext\"] = values\n\n        return {\"data\": [trace], \"layout\": {}}\n</code></pre>"},{"location":"reference/dvc_render/table/","title":"Table","text":""},{"location":"reference/dvc_render/table/#dvc_render.table.TableRenderer","title":"<code>TableRenderer</code>","text":"<p>               Bases: <code>Renderer</code></p> <p>Renderer for tables.</p> Source code in <code>dvc_render/table.py</code> <pre><code>class TableRenderer(Renderer):\n    \"\"\"Renderer for tables.\"\"\"\n\n    TYPE = \"table\"\n    DIV = \"\"\"\n        &lt;div id=\"{id}\" style=\"text-align: center; padding: 10x\"&gt;\n            &lt;p&gt;{id}&lt;/p&gt;\n            &lt;div style=\"display: flex;justify-content: center;\"&gt;\n                {partial}\n            &lt;/div&gt;\n        &lt;/div&gt;\"\"\"\n\n    SCRIPTS = \"\"\n\n    EXTENSIONS = {\".yml\", \".yaml\", \".json\"}\n\n    @classmethod\n    def to_tabulate(cls, datapoints, tablefmt):\n        \"\"\"Convert datapoints to tabulate format\"\"\"\n        if tabulate is None:\n            raise ImportError(f\"{cls.__name__} requires `tabulate`.\")  # noqa: TRY003\n        data = list_dict_to_dict_list(datapoints)\n        return tabulate(data, headers=\"keys\", tablefmt=tablefmt)\n\n    def partial_html(self, **kwargs) -&gt; str:  # noqa: ARG002\n        return self.to_tabulate(self.datapoints, tablefmt=\"html\")\n\n    def generate_markdown(self, report_path=None) -&gt; str:  # noqa: ARG002\n        table = self.to_tabulate(self.datapoints, tablefmt=\"github\")\n        return f\"\\n{self.name}\\n\\n{table}\"\n</code></pre>"},{"location":"reference/dvc_render/table/#dvc_render.table.TableRenderer.to_tabulate","title":"<code>to_tabulate(datapoints, tablefmt)</code>  <code>classmethod</code>","text":"<p>Convert datapoints to tabulate format</p> Source code in <code>dvc_render/table.py</code> <pre><code>@classmethod\ndef to_tabulate(cls, datapoints, tablefmt):\n    \"\"\"Convert datapoints to tabulate format\"\"\"\n    if tabulate is None:\n        raise ImportError(f\"{cls.__name__} requires `tabulate`.\")  # noqa: TRY003\n    data = list_dict_to_dict_list(datapoints)\n    return tabulate(data, headers=\"keys\", tablefmt=tablefmt)\n</code></pre>"},{"location":"reference/dvc_render/utils/","title":"Utils","text":""},{"location":"reference/dvc_render/utils/#dvc_render.utils.list_dict_to_dict_list","title":"<code>list_dict_to_dict_list(list_dict)</code>","text":"<p>Convert from list of dictionaries to dictionary of lists.</p> Source code in <code>dvc_render/utils.py</code> <pre><code>def list_dict_to_dict_list(list_dict):\n    \"\"\"Convert from list of dictionaries to dictionary of lists.\"\"\"\n    if not list_dict:\n        return {}\n    flat_list_dict = [flatten(d, reducer=\"dot\") for d in list_dict]\n    return {k: [x[k] for x in flat_list_dict] for k in flat_list_dict[0]}\n</code></pre>"},{"location":"reference/dvc_render/vega/","title":"Vega","text":""},{"location":"reference/dvc_render/vega/#dvc_render.vega.VegaRenderer","title":"<code>VegaRenderer</code>","text":"<p>               Bases: <code>Renderer</code></p> <p>Renderer for vega plots.</p> Source code in <code>dvc_render/vega.py</code> <pre><code>class VegaRenderer(Renderer):\n    \"\"\"Renderer for vega plots.\"\"\"\n\n    TYPE = \"vega\"\n\n    DIV = \"\"\"\n    &lt;div id = \"{id}\"&gt;\n        &lt;script type = \"text/javascript\"&gt;\n            var spec = {partial};\n            vegaEmbed('#{id}', spec);\n        &lt;/script&gt;\n    &lt;/div&gt;\n    \"\"\"\n\n    SCRIPTS = \"\"\"\n    &lt;script src=\"https://cdn.jsdelivr.net/npm/vega@5.20.2\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://cdn.jsdelivr.net/npm/vega-lite@5.2.0\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://cdn.jsdelivr.net/npm/vega-embed@6.18.2\"&gt;&lt;/script&gt;\n    \"\"\"\n\n    EXTENSIONS = {\".yml\", \".yaml\", \".json\", \".csv\", \".tsv\"}\n\n    def __init__(self, datapoints: list, name: str, **properties):\n        super().__init__(datapoints, name, **properties)\n        self.template = get_template(\n            self.properties.get(\"template\", None),\n            self.properties.get(\"template_dir\", None),\n        )\n\n        self._split_content: dict[str, str] = {}\n\n    def get_filled_template(  # noqa: C901\n        self,\n        split_anchors: Optional[list[str]] = None,\n        strict: bool = True,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Returns a functional vega specification\"\"\"\n        self.template.reset()\n        if not self.datapoints:\n            return {}\n\n        if split_anchors is None:\n            split_anchors = []\n\n        if strict:\n            if self.properties.get(\"x\"):\n                self.template.check_field_exists(\n                    self.datapoints, self.properties.get(\"x\")\n                )\n            if self.properties.get(\"y\"):\n                self.template.check_field_exists(\n                    self.datapoints, self.properties.get(\"y\")\n                )\n        self.properties.setdefault(\"title\", \"\")\n        self.properties.setdefault(\"x_label\", self.properties.get(\"x\"))\n        self.properties.setdefault(\"y_label\", self.properties.get(\"y\"))\n        self.properties.setdefault(\"data\", self.datapoints)\n\n        varied_keys = self._process_optional_anchors(split_anchors)\n        self._update_datapoints(varied_keys)\n\n        names = [\"title\", \"x\", \"y\", \"x_label\", \"y_label\", \"data\"]\n        for name in names:\n            value = self.properties.get(name)\n            if value is None:\n                continue\n\n            if name in split_anchors:\n                self._set_split_content(name, value)\n                continue\n\n            if name == \"data\":\n                if not self.template.has_anchor(name):\n                    anchor = self.template.anchor(name)\n                    raise BadTemplateError(  # noqa: TRY003\n                        f\"Template '{self.template.name}' \"\n                        f\"is not using '{anchor}' anchor\"\n                    )\n            elif name in {\"x\", \"y\"}:\n                value = self.template.escape_special_characters(value)\n            self.template.fill_anchor(name, value)\n\n        return self.template.content\n\n    def get_partial_filled_template(self):\n        \"\"\"\n        Returns a partially filled template along with the split out anchor content\n        \"\"\"\n        content = self.get_filled_template(\n            split_anchors=SPLIT_ANCHORS,\n            strict=True,\n        )\n        return content, {\"anchor_definitions\": self._split_content}\n\n    def get_template(self):\n        \"\"\"\n        Returns unfilled template (for Studio)\n        \"\"\"\n        return self.template.content\n\n    def partial_html(self, **kwargs) -&gt; str:  # noqa: ARG002\n        content = self.get_filled_template()\n        return json.dumps(content)\n\n    def generate_markdown(self, report_path=None) -&gt; str:\n        if not isinstance(self.template, LinearTemplate):\n            warn(\"`generate_markdown` can only be used with `LinearTemplate`\")  # noqa: B028\n            return \"\"\n        try:\n            from matplotlib import pyplot as plt\n        except ImportError as e:\n            raise ImportError(\"matplotlib is required for `generate_markdown`\") from e  # noqa: TRY003\n\n        data = list_dict_to_dict_list(self.datapoints)\n        if data:\n            if report_path:\n                report_folder = Path(report_path).parent\n                output_file = report_folder / self.name\n                output_file = output_file.with_suffix(\".png\")\n                output_file.parent.mkdir(exist_ok=True, parents=True)\n            else:\n                output_file = io.BytesIO()  # type: ignore[assignment]\n\n            x = self.properties.get(\"x\")\n            y = self.properties.get(\"y\")\n            data[x] = list(map(float, data[x]))\n            data[y] = list(map(float, data[y]))\n\n            if x is not None and y is not None:\n                plt.title(self.properties.get(\"title\", Path(self.name).stem))\n                plt.xlabel(self.properties.get(\"x_label\", x))\n                plt.ylabel(self.properties.get(\"y_label\", y))\n                plt.plot(x, y, data=data)\n                plt.tight_layout()\n                plt.savefig(output_file)\n                plt.close()\n\n                if report_path:\n                    return f\"\\n![{self.name}]({output_file.relative_to(report_folder)})\"\n\n                base64_str = base64.b64encode(output_file.getvalue()).decode()  # type: ignore[attr-defined]\n                src = f\"data:image/png;base64,{base64_str}\"\n\n                return f\"\\n![{self.name}]({src})\"\n\n        return \"\"\n\n    def get_revs(self):\n        \"\"\"\n        Returns all revisions that were collected that have datapoints.\n        \"\"\"\n        return (\n            self.properties.get(\"revs_with_datapoints\", [])\n            or self._get_revs_from_datapoints()\n        )\n\n    def _get_revs_from_datapoints(self):\n        revs = []\n        for datapoint in self.datapoints:\n            rev = datapoint.get(\"rev\")\n            if rev and rev not in revs:\n                revs.append(rev)\n        return revs\n\n    def _process_optional_anchors(self, split_anchors: list[str]):\n        optional_anchors = [\n            anchor for anchor in OPTIONAL_ANCHORS if self.template.has_anchor(anchor)\n        ]\n        if not optional_anchors:\n            return None\n\n        self._fill_color(split_anchors, optional_anchors)\n        self._fill_set_encoding(split_anchors, optional_anchors)\n\n        y_definitions = self.properties.get(\"anchors_y_definitions\", [])\n        is_single_source = len(y_definitions) &lt;= 1\n\n        if is_single_source:\n            self._process_single_source_plot(split_anchors, optional_anchors)\n            return []\n\n        return self._process_multi_source_plot(\n            split_anchors, optional_anchors, y_definitions\n        )\n\n    def _fill_color(self, split_anchors: list[str], optional_anchors: list[str]):\n        all_revs = self.get_revs()\n        self._fill_optional_anchor_mapping(\n            split_anchors,\n            optional_anchors,\n            REV,\n            \"color\",\n            all_revs,\n        )\n\n    def _fill_set_encoding(self, split_anchors: list[str], optional_anchors: list[str]):\n        for name, encoding in [\n            (\"zoom_and_pan\", {\"name\": \"grid\", \"select\": \"interval\", \"bind\": \"scales\"}),\n            (\"plot_height\", 300),\n            (\"plot_width\", 300),\n        ]:\n            self._fill_optional_anchor(split_anchors, optional_anchors, name, encoding)\n\n    def _process_single_source_plot(\n        self, split_anchors: list[str], optional_anchors: list[str]\n    ):\n        self._fill_group_by(split_anchors, optional_anchors, [REV])\n        self._fill_optional_anchor(\n            split_anchors, optional_anchors, \"pivot_field\", \"datum.rev\"\n        )\n        self._fill_tooltip(split_anchors, optional_anchors)\n        for anchor in optional_anchors:\n            self.template.fill_anchor(anchor, {})\n\n    def _process_multi_source_plot(\n        self,\n        split_anchors: list[str],\n        optional_anchors: list[str],\n        y_definitions: list[dict[str, str]],\n    ):\n        varied_keys, domain = self._collect_variations(y_definitions)\n\n        self._fill_optional_multi_source_anchors(\n            split_anchors, optional_anchors, varied_keys, domain\n        )\n        return varied_keys\n\n    def _collect_variations(\n        self, y_definitions: list[dict[str, str]]\n    ) -&gt; tuple[list[str], list[str]]:\n        varied_values = defaultdict(set)\n        for defn in y_definitions:\n            for key in FILENAME_FIELD:\n                varied_values[key].add(defn.get(key, None))\n            varied_values[CONCAT_FIELDS].add(\n                FIELD_SEPARATOR.join([defn.get(FILENAME, \"\"), defn.get(FIELD, \"\")])\n            )\n\n        varied_keys = []\n\n        for filename_or_field in FILENAME_FIELD:\n            value_set = varied_values[filename_or_field]\n            num_values = len(value_set)\n            if num_values == 1:\n                continue\n            varied_keys.append(filename_or_field)\n\n        domain = self._get_domain(varied_keys, varied_values)\n\n        return varied_keys, domain\n\n    def _fill_optional_multi_source_anchors(\n        self,\n        split_anchors: list[str],\n        optional_anchors: list[str],\n        varied_keys: list[str],\n        domain: list[str],\n    ):\n        if not optional_anchors:\n            return\n\n        concat_field = FIELD_SEPARATOR.join(varied_keys)\n        self._fill_group_by(split_anchors, optional_anchors, [REV, concat_field])\n\n        self._fill_optional_anchor(\n            split_anchors,\n            optional_anchors,\n            \"pivot_field\",\n            f\" + '{FIELD_SEPARATOR}' + \".join(\n                [f\"datum.{key}\" for key in [REV, *varied_keys]]\n            ),\n        )\n\n        self._fill_optional_anchor(\n            split_anchors, optional_anchors, \"row\", {\"field\": concat_field, \"sort\": []}\n        )\n        self._fill_optional_anchor(\n            split_anchors,\n            optional_anchors,\n            \"column\",\n            {\"field\": concat_field, \"sort\": []},\n        )\n\n        self._fill_tooltip(split_anchors, optional_anchors, [concat_field])\n\n        for anchor in [\"stroke_dash\", \"shape\"]:\n            self._fill_optional_anchor_mapping(\n                split_anchors, optional_anchors, concat_field, anchor, domain\n            )\n\n    def _fill_group_by(\n        self,\n        split_anchors: list[str],\n        optional_anchors: list[str],\n        group_by: list[str],\n    ):\n        self._fill_optional_anchor(\n            split_anchors, optional_anchors, \"group_by\", group_by\n        )\n        self._fill_optional_anchor(\n            split_anchors,\n            optional_anchors,\n            \"group_by_x\",\n            [*group_by, self.properties.get(\"x\")],\n        )\n        self._fill_optional_anchor(\n            split_anchors,\n            optional_anchors,\n            \"group_by_y\",\n            [*group_by, self.properties.get(\"y\")],\n        )\n\n    def _fill_tooltip(\n        self,\n        split_anchors: list[str],\n        optional_anchors: list[str],\n        additional_fields: Optional[list[str]] = None,\n    ):\n        if not additional_fields:\n            additional_fields = []\n        self._fill_optional_anchor(\n            split_anchors,\n            optional_anchors,\n            \"tooltip\",\n            [\n                {\"field\": REV},\n                {\"field\": self.properties.get(\"x\")},\n                {\"field\": self.properties.get(\"y\")},\n                *[{\"field\": field} for field in additional_fields],\n            ],\n        )\n\n    def _fill_optional_anchor(\n        self,\n        split_anchors: list[str],\n        optional_anchors: list[str],\n        name: str,\n        value: Any,\n    ):\n        if name not in optional_anchors:\n            return\n\n        optional_anchors.remove(name)\n\n        if name in split_anchors:\n            self._set_split_content(name, value)\n            return\n\n        self.template.fill_anchor(name, value)\n\n    def _get_domain(self, varied_keys: list[str], varied_values: dict[str, set]):\n        if len(varied_keys) == 2:\n            domain = list(varied_values[CONCAT_FIELDS])\n        else:\n            filename_or_field = varied_keys[0]\n            domain = list(varied_values[filename_or_field])\n\n        domain.sort()\n        return domain\n\n    def _fill_optional_anchor_mapping(\n        self,\n        split_anchors: list[str],\n        optional_anchors: list[str],\n        field: str,\n        name: str,\n        domain: list[str],\n    ):  # pylint: disable=too-many-arguments\n        if name not in optional_anchors:\n            return\n\n        optional_anchors.remove(name)\n\n        encoding = self._get_optional_anchor_mapping(field, name, domain)\n\n        if name in split_anchors:\n            self._set_split_content(name, encoding)\n            return\n\n        self.template.fill_anchor(name, encoding)\n\n    def _get_optional_anchor_mapping(\n        self,\n        field: str,\n        name: str,\n        domain: list[str],\n    ):\n        full_range_values: list[Any] = OPTIONAL_ANCHOR_RANGES.get(name, [])\n        anchor_range_values = full_range_values.copy()\n\n        anchor_range = []\n        for _ in range(len(domain)):\n            if not anchor_range_values:\n                anchor_range_values = full_range_values.copy()\n            range_value = anchor_range_values.pop(0)\n            anchor_range.append(range_value)\n\n        legend = (\n            # fix stroke dash and shape legend entry appearance (use empty shapes)\n            {\"legend\": {\"symbolFillColor\": \"transparent\", \"symbolStrokeColor\": \"grey\"}}\n            if name != \"color\"\n            else {}\n        )\n\n        return {\n            \"field\": field,\n            \"scale\": {\"domain\": domain, \"range\": anchor_range},\n            **legend,\n        }\n\n    def _update_datapoints(self, varied_keys: Optional[list[str]] = None):\n        if varied_keys is None:\n            return\n\n        if len(varied_keys) == 2:\n            to_concatenate = varied_keys\n            to_remove = varied_keys\n        else:\n            to_concatenate = []\n            to_remove = [key for key in FILENAME_FIELD if key not in varied_keys]\n\n        for datapoint in self.datapoints:\n            if to_concatenate:\n                concat_key = FIELD_SEPARATOR.join(to_concatenate)\n                datapoint[concat_key] = FIELD_SEPARATOR.join(\n                    [datapoint.get(k) for k in to_concatenate]\n                )\n            for key in to_remove:\n                datapoint.pop(key, None)\n\n    def _set_split_content(self, name: str, value: Any):\n        self._split_content[Template.anchor(name)] = value\n</code></pre>"},{"location":"reference/dvc_render/vega/#dvc_render.vega.VegaRenderer.get_filled_template","title":"<code>get_filled_template(split_anchors=None, strict=True)</code>","text":"<p>Returns a functional vega specification</p> Source code in <code>dvc_render/vega.py</code> <pre><code>def get_filled_template(  # noqa: C901\n    self,\n    split_anchors: Optional[list[str]] = None,\n    strict: bool = True,\n) -&gt; dict[str, Any]:\n    \"\"\"Returns a functional vega specification\"\"\"\n    self.template.reset()\n    if not self.datapoints:\n        return {}\n\n    if split_anchors is None:\n        split_anchors = []\n\n    if strict:\n        if self.properties.get(\"x\"):\n            self.template.check_field_exists(\n                self.datapoints, self.properties.get(\"x\")\n            )\n        if self.properties.get(\"y\"):\n            self.template.check_field_exists(\n                self.datapoints, self.properties.get(\"y\")\n            )\n    self.properties.setdefault(\"title\", \"\")\n    self.properties.setdefault(\"x_label\", self.properties.get(\"x\"))\n    self.properties.setdefault(\"y_label\", self.properties.get(\"y\"))\n    self.properties.setdefault(\"data\", self.datapoints)\n\n    varied_keys = self._process_optional_anchors(split_anchors)\n    self._update_datapoints(varied_keys)\n\n    names = [\"title\", \"x\", \"y\", \"x_label\", \"y_label\", \"data\"]\n    for name in names:\n        value = self.properties.get(name)\n        if value is None:\n            continue\n\n        if name in split_anchors:\n            self._set_split_content(name, value)\n            continue\n\n        if name == \"data\":\n            if not self.template.has_anchor(name):\n                anchor = self.template.anchor(name)\n                raise BadTemplateError(  # noqa: TRY003\n                    f\"Template '{self.template.name}' \"\n                    f\"is not using '{anchor}' anchor\"\n                )\n        elif name in {\"x\", \"y\"}:\n            value = self.template.escape_special_characters(value)\n        self.template.fill_anchor(name, value)\n\n    return self.template.content\n</code></pre>"},{"location":"reference/dvc_render/vega/#dvc_render.vega.VegaRenderer.get_partial_filled_template","title":"<code>get_partial_filled_template()</code>","text":"<p>Returns a partially filled template along with the split out anchor content</p> Source code in <code>dvc_render/vega.py</code> <pre><code>def get_partial_filled_template(self):\n    \"\"\"\n    Returns a partially filled template along with the split out anchor content\n    \"\"\"\n    content = self.get_filled_template(\n        split_anchors=SPLIT_ANCHORS,\n        strict=True,\n    )\n    return content, {\"anchor_definitions\": self._split_content}\n</code></pre>"},{"location":"reference/dvc_render/vega/#dvc_render.vega.VegaRenderer.get_revs","title":"<code>get_revs()</code>","text":"<p>Returns all revisions that were collected that have datapoints.</p> Source code in <code>dvc_render/vega.py</code> <pre><code>def get_revs(self):\n    \"\"\"\n    Returns all revisions that were collected that have datapoints.\n    \"\"\"\n    return (\n        self.properties.get(\"revs_with_datapoints\", [])\n        or self._get_revs_from_datapoints()\n    )\n</code></pre>"},{"location":"reference/dvc_render/vega/#dvc_render.vega.VegaRenderer.get_template","title":"<code>get_template()</code>","text":"<p>Returns unfilled template (for Studio)</p> Source code in <code>dvc_render/vega.py</code> <pre><code>def get_template(self):\n    \"\"\"\n    Returns unfilled template (for Studio)\n    \"\"\"\n    return self.template.content\n</code></pre>"},{"location":"reference/dvc_render/vega_templates/","title":"Vega templates","text":""},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template","title":"<code>Template</code>","text":"Source code in <code>dvc_render/vega_templates.py</code> <pre><code>class Template:\n    EXTENSION = \".json\"\n    ANCHOR = \"&lt;DVC_METRIC_{}&gt;\"\n\n    DEFAULT_CONTENT: dict[str, Any] = {}\n    DEFAULT_NAME: str = \"\"\n\n    def __init__(\n        self, content: Optional[dict[str, Any]] = None, name: Optional[str] = None\n    ):\n        if (\n            content\n            and not isinstance(content, dict)\n            or self.DEFAULT_CONTENT\n            and not isinstance(self.DEFAULT_CONTENT, dict)\n        ):\n            raise BadTemplateError\n        self._original_content = content or self.DEFAULT_CONTENT\n        self.content: dict[str, Any] = self._original_content\n        self.name = name or self.DEFAULT_NAME\n        self.filename = Path(self.name).with_suffix(self.EXTENSION)\n\n    @classmethod\n    def anchor(cls, name):\n        \"Get ANCHOR formatted with name.\"\n        return cls.ANCHOR.format(name.upper())\n\n    @classmethod\n    def escape_special_characters(cls, value: str) -&gt; str:\n        \"Escape special characters in `value`\"\n        for character in (\".\", \"[\", \"]\"):\n            value = value.replace(character, \"\\\\\" + character)\n        return value\n\n    @staticmethod\n    def check_field_exists(data, field):\n        \"Raise NoFieldInDataError if `field` not in `data`.\"\n        if not any(field in row for row in data):\n            raise NoFieldInDataError(field)\n\n    def reset(self):\n        \"\"\"Reset self.content to its original state.\"\"\"\n        self.content = self._original_content\n\n    def has_anchor(self, name) -&gt; bool:\n        \"Check if ANCHOR formatted with name is in content.\"\n        return find_value(self.content, self.anchor(name))\n\n    def fill_anchor(self, name, value) -&gt; None:\n        \"Replace anchor `name` with `value` in content.\"\n        self.content = dict_replace_value(self.content, self.anchor(name), value)\n</code></pre>"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.anchor","title":"<code>anchor(name)</code>  <code>classmethod</code>","text":"<p>Get ANCHOR formatted with name.</p> Source code in <code>dvc_render/vega_templates.py</code> <pre><code>@classmethod\ndef anchor(cls, name):\n    \"Get ANCHOR formatted with name.\"\n    return cls.ANCHOR.format(name.upper())\n</code></pre>"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.check_field_exists","title":"<code>check_field_exists(data, field)</code>  <code>staticmethod</code>","text":"<p>Raise NoFieldInDataError if <code>field</code> not in <code>data</code>.</p> Source code in <code>dvc_render/vega_templates.py</code> <pre><code>@staticmethod\ndef check_field_exists(data, field):\n    \"Raise NoFieldInDataError if `field` not in `data`.\"\n    if not any(field in row for row in data):\n        raise NoFieldInDataError(field)\n</code></pre>"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.escape_special_characters","title":"<code>escape_special_characters(value)</code>  <code>classmethod</code>","text":"<p>Escape special characters in <code>value</code></p> Source code in <code>dvc_render/vega_templates.py</code> <pre><code>@classmethod\ndef escape_special_characters(cls, value: str) -&gt; str:\n    \"Escape special characters in `value`\"\n    for character in (\".\", \"[\", \"]\"):\n        value = value.replace(character, \"\\\\\" + character)\n    return value\n</code></pre>"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.fill_anchor","title":"<code>fill_anchor(name, value)</code>","text":"<p>Replace anchor <code>name</code> with <code>value</code> in content.</p> Source code in <code>dvc_render/vega_templates.py</code> <pre><code>def fill_anchor(self, name, value) -&gt; None:\n    \"Replace anchor `name` with `value` in content.\"\n    self.content = dict_replace_value(self.content, self.anchor(name), value)\n</code></pre>"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.has_anchor","title":"<code>has_anchor(name)</code>","text":"<p>Check if ANCHOR formatted with name is in content.</p> Source code in <code>dvc_render/vega_templates.py</code> <pre><code>def has_anchor(self, name) -&gt; bool:\n    \"Check if ANCHOR formatted with name is in content.\"\n    return find_value(self.content, self.anchor(name))\n</code></pre>"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.reset","title":"<code>reset()</code>","text":"<p>Reset self.content to its original state.</p> Source code in <code>dvc_render/vega_templates.py</code> <pre><code>def reset(self):\n    \"\"\"Reset self.content to its original state.\"\"\"\n    self.content = self._original_content\n</code></pre>"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.dump_templates","title":"<code>dump_templates(output, targets=None)</code>","text":"<p>Write TEMPLATES in <code>.json</code> format to <code>output</code>.</p> Source code in <code>dvc_render/vega_templates.py</code> <pre><code>def dump_templates(output: \"StrPath\", targets: Optional[list] = None) -&gt; None:\n    \"Write TEMPLATES in `.json` format to `output`.\"\n    output = Path(output)\n    output.mkdir(exist_ok=True)\n\n    if targets:\n        templates = [\n            template for template in TEMPLATES if template.DEFAULT_NAME in targets\n        ]\n    else:\n        templates = TEMPLATES\n\n    for template_cls in templates:\n        template = template_cls()\n        path = output / template.filename\n\n        if path.exists():\n            content = path.read_text(encoding=\"utf-8\")\n            if content != template.content:\n                raise TemplateContentDoesNotMatchError(template.DEFAULT_NAME, str(path))\n        else:\n            path.write_text(json.dumps(template.content), encoding=\"utf-8\")\n</code></pre>"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.get_template","title":"<code>get_template(template=None, template_dir=None, fs=None)</code>","text":"<p>Return template instance based on given template arg.</p> <p>If template is already an instance, return it. If template is None, return default <code>linear</code> template. If template is a path, will try to find it:     - Inside <code>template_dir</code>     - As a relative path to cwd. If template matches one of the DEFAULT_NAMEs in TEMPLATES, return an instance of the one matching.</p> Source code in <code>dvc_render/vega_templates.py</code> <pre><code>def get_template(\n    template: Union[Optional[str], Template] = None,\n    template_dir: Optional[str] = None,\n    fs=None,\n) -&gt; Template:\n    \"\"\"Return template instance based on given template arg.\n\n    If template is already an instance, return it.\n    If template is None, return default `linear` template.\n    If template is a path, will try to find it:\n        - Inside `template_dir`\n        - As a relative path to cwd.\n    If template matches one of the DEFAULT_NAMEs in TEMPLATES,\n    return an instance of the one matching.\n    \"\"\"\n    if isinstance(template, Template):\n        return template\n\n    if template is None:\n        template = \"linear\"\n\n    template_path = _find_template(template, template_dir, fs)\n\n    _open = open if fs is None else fs.open\n    if template_path:\n        with _open(template_path, encoding=\"utf-8\") as f:\n            content = json.load(f)\n        return Template(content, name=template)\n\n    for template_cls in TEMPLATES:\n        if template == template_cls.DEFAULT_NAME:\n            return template_cls()\n\n    raise TemplateNotFoundError(template)\n</code></pre>"}]}