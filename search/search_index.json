{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Dvc Render API Reference","title":"Welcome to Dvc Render"},{"location":"#welcome-to-dvc-render","text":"API Reference","title":"Welcome to Dvc Render"},{"location":"reference/dvc_render/","text":"Library for rendering DVC plots","title":"Dvc render"},{"location":"reference/dvc_render/base/","text":"Renderer Bases: abc . ABC Base Renderer class Source code in dvc_render/base.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class Renderer ( abc . ABC ): \"\"\"Base Renderer class\"\"\" DIV = \"\"\" <div id=\" {id} \"> {partial} </div> \"\"\" EXTENSIONS : Iterable [ str ] = {} def __init__ ( self , datapoints : List = None , name : str = None , ** properties ): self . datapoints = datapoints or [] self . name = name or \"\" self . properties = properties @abc . abstractmethod def partial_html ( self , ** kwargs ) -> str : \"\"\" Us this method to generate HTML content, to fill `{partial}` inside self.DIV. \"\"\" raise NotImplementedError @property @abc . abstractmethod def TYPE ( self ): # pylint: disable=missing-function-docstring raise NotImplementedError @property @abc . abstractmethod def SCRIPTS ( self ): # pylint: disable=missing-function-docstring raise NotImplementedError @staticmethod def remove_special_chars ( string : str ) -> str : \"Ensure string is valid HTML id.\" return string . translate ( { ord ( c ): \"_\" for c in r \"!@#$%^&*()[] {} ;,<>?\\/:.|`~=_+\" } ) def generate_html ( self , html_path = None ) -> str : \"Return `DIV` formatted with `partial_html`.\" partial = self . partial_html ( html_path = html_path ) if partial : div_id = self . remove_special_chars ( self . name ) div_id = f \"plot_ { div_id } \" return self . DIV . format ( id = div_id , partial = partial ) return \"\" @classmethod def matches ( cls , filename , properties # pylint: disable=unused-argument ) -> bool : \"Check if the Renderer is suitable.\" return Path ( filename ) . suffix in cls . EXTENSIONS generate_html ( html_path = None ) Return DIV formatted with partial_html . Source code in dvc_render/base.py 54 55 56 57 58 59 60 61 62 63 def generate_html ( self , html_path = None ) -> str : \"Return `DIV` formatted with `partial_html`.\" partial = self . partial_html ( html_path = html_path ) if partial : div_id = self . remove_special_chars ( self . name ) div_id = f \"plot_ { div_id } \" return self . DIV . format ( id = div_id , partial = partial ) return \"\" matches ( filename , properties ) classmethod Check if the Renderer is suitable. Source code in dvc_render/base.py 65 66 67 68 69 70 @classmethod def matches ( cls , filename , properties # pylint: disable=unused-argument ) -> bool : \"Check if the Renderer is suitable.\" return Path ( filename ) . suffix in cls . EXTENSIONS partial_html ( ** kwargs ) abstractmethod Us this method to generate HTML content, to fill {partial} inside self.DIV. Source code in dvc_render/base.py 29 30 31 32 33 34 35 @abc . abstractmethod def partial_html ( self , ** kwargs ) -> str : \"\"\" Us this method to generate HTML content, to fill `{partial}` inside self.DIV. \"\"\" raise NotImplementedError remove_special_chars ( string ) staticmethod Ensure string is valid HTML id. Source code in dvc_render/base.py 47 48 49 50 51 52 @staticmethod def remove_special_chars ( string : str ) -> str : \"Ensure string is valid HTML id.\" return string . translate ( { ord ( c ): \"_\" for c in r \"!@#$%^&*()[] {} ;,<>?\\/:.|`~=_+\" } )","title":"Base"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer","text":"Bases: abc . ABC Base Renderer class Source code in dvc_render/base.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class Renderer ( abc . ABC ): \"\"\"Base Renderer class\"\"\" DIV = \"\"\" <div id=\" {id} \"> {partial} </div> \"\"\" EXTENSIONS : Iterable [ str ] = {} def __init__ ( self , datapoints : List = None , name : str = None , ** properties ): self . datapoints = datapoints or [] self . name = name or \"\" self . properties = properties @abc . abstractmethod def partial_html ( self , ** kwargs ) -> str : \"\"\" Us this method to generate HTML content, to fill `{partial}` inside self.DIV. \"\"\" raise NotImplementedError @property @abc . abstractmethod def TYPE ( self ): # pylint: disable=missing-function-docstring raise NotImplementedError @property @abc . abstractmethod def SCRIPTS ( self ): # pylint: disable=missing-function-docstring raise NotImplementedError @staticmethod def remove_special_chars ( string : str ) -> str : \"Ensure string is valid HTML id.\" return string . translate ( { ord ( c ): \"_\" for c in r \"!@#$%^&*()[] {} ;,<>?\\/:.|`~=_+\" } ) def generate_html ( self , html_path = None ) -> str : \"Return `DIV` formatted with `partial_html`.\" partial = self . partial_html ( html_path = html_path ) if partial : div_id = self . remove_special_chars ( self . name ) div_id = f \"plot_ { div_id } \" return self . DIV . format ( id = div_id , partial = partial ) return \"\" @classmethod def matches ( cls , filename , properties # pylint: disable=unused-argument ) -> bool : \"Check if the Renderer is suitable.\" return Path ( filename ) . suffix in cls . EXTENSIONS","title":"Renderer"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.generate_html","text":"Return DIV formatted with partial_html . Source code in dvc_render/base.py 54 55 56 57 58 59 60 61 62 63 def generate_html ( self , html_path = None ) -> str : \"Return `DIV` formatted with `partial_html`.\" partial = self . partial_html ( html_path = html_path ) if partial : div_id = self . remove_special_chars ( self . name ) div_id = f \"plot_ { div_id } \" return self . DIV . format ( id = div_id , partial = partial ) return \"\"","title":"generate_html()"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.matches","text":"Check if the Renderer is suitable. Source code in dvc_render/base.py 65 66 67 68 69 70 @classmethod def matches ( cls , filename , properties # pylint: disable=unused-argument ) -> bool : \"Check if the Renderer is suitable.\" return Path ( filename ) . suffix in cls . EXTENSIONS","title":"matches()"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.partial_html","text":"Us this method to generate HTML content, to fill {partial} inside self.DIV. Source code in dvc_render/base.py 29 30 31 32 33 34 35 @abc . abstractmethod def partial_html ( self , ** kwargs ) -> str : \"\"\" Us this method to generate HTML content, to fill `{partial}` inside self.DIV. \"\"\" raise NotImplementedError","title":"partial_html()"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.remove_special_chars","text":"Ensure string is valid HTML id. Source code in dvc_render/base.py 47 48 49 50 51 52 @staticmethod def remove_special_chars ( string : str ) -> str : \"Ensure string is valid HTML id.\" return string . translate ( { ord ( c ): \"_\" for c in r \"!@#$%^&*()[] {} ;,<>?\\/:.|`~=_+\" } )","title":"remove_special_chars()"},{"location":"reference/dvc_render/exceptions/","text":"","title":"Exceptions"},{"location":"reference/dvc_render/html/","text":"HTML Source code in dvc_render/html.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class HTML : SCRIPTS_PLACEHOLDER = \"scripts\" PLOTS_PLACEHOLDER = \"plot_divs\" PLOTS_PLACEHOLDER_FORMAT_STR = f \" {{ { PLOTS_PLACEHOLDER } }} \" REFRESH_PLACEHOLDER = \"refresh_tag\" REFRESH_TAG = '<meta http-equiv=\"refresh\" content=\" {} \">' def __init__ ( self , template : Optional [ str ] = None , refresh_seconds : Optional [ int ] = None , ): template = template or PAGE_HTML if self . PLOTS_PLACEHOLDER_FORMAT_STR not in template : raise MissingPlaceholderError ( self . PLOTS_PLACEHOLDER_FORMAT_STR ) self . template = template self . elements : List [ str ] = [] self . scripts : str = \"\" self . refresh_tag = \"\" if refresh_seconds is not None : self . refresh_tag = self . REFRESH_TAG . format ( refresh_seconds ) def with_metrics ( self , metrics : Dict [ str , Dict ]) -> \"HTML\" : \"Adds metrics element.\" header : List [ str ] = [] rows : List [ List [ str ]] = [] for _ , rev_data in metrics . items (): for _ , data in rev_data . items (): if not header : header . extend ( sorted ( data . keys ())) rows . append ([ data [ key ] for key in header ]) self . elements . append ( tabulate . tabulate ( rows , header , tablefmt = \"html\" )) return self def with_scripts ( self , scripts : str ) -> \"HTML\" : \"Extend scripts element.\" if scripts not in self . scripts : self . scripts += f \" \\n { scripts } \" return self def with_element ( self , html : str ) -> \"HTML\" : \"Adds custom html element.\" self . elements . append ( html ) return self def embed ( self ) -> str : \"Format HTML template with all elements.\" kwargs = { self . SCRIPTS_PLACEHOLDER : self . scripts , self . PLOTS_PLACEHOLDER : \" \\n \" . join ( self . elements ), self . REFRESH_PLACEHOLDER : self . refresh_tag , } return self . template . format ( ** kwargs ) embed () Format HTML template with all elements. Source code in dvc_render/html.py 79 80 81 82 83 84 85 86 def embed ( self ) -> str : \"Format HTML template with all elements.\" kwargs = { self . SCRIPTS_PLACEHOLDER : self . scripts , self . PLOTS_PLACEHOLDER : \" \\n \" . join ( self . elements ), self . REFRESH_PLACEHOLDER : self . refresh_tag , } return self . template . format ( ** kwargs ) with_element ( html ) Adds custom html element. Source code in dvc_render/html.py 74 75 76 77 def with_element ( self , html : str ) -> \"HTML\" : \"Adds custom html element.\" self . elements . append ( html ) return self with_metrics ( metrics ) Adds metrics element. Source code in dvc_render/html.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def with_metrics ( self , metrics : Dict [ str , Dict ]) -> \"HTML\" : \"Adds metrics element.\" header : List [ str ] = [] rows : List [ List [ str ]] = [] for _ , rev_data in metrics . items (): for _ , data in rev_data . items (): if not header : header . extend ( sorted ( data . keys ())) rows . append ([ data [ key ] for key in header ]) self . elements . append ( tabulate . tabulate ( rows , header , tablefmt = \"html\" )) return self with_scripts ( scripts ) Extend scripts element. Source code in dvc_render/html.py 68 69 70 71 72 def with_scripts ( self , scripts : str ) -> \"HTML\" : \"Extend scripts element.\" if scripts not in self . scripts : self . scripts += f \" \\n { scripts } \" return self render_html ( renderers , output_file , metrics = None , template_path = None , refresh_seconds = None ) User renderers to fill an HTML template and write to path. Source code in dvc_render/html.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def render_html ( renderers : List [ \"Renderer\" ], output_file : \"StrPath\" , metrics : Optional [ Dict [ str , Dict ]] = None , template_path : Optional [ \"StrPath\" ] = None , refresh_seconds : Optional [ int ] = None , ) -> \"StrPath\" : \"User renderers to fill an HTML template and write to path.\" output_path = Path ( output_file ) output_path . parent . mkdir ( exist_ok = True ) page_html = None if template_path : with open ( template_path , encoding = \"utf-8\" ) as fobj : page_html = fobj . read () document = HTML ( page_html , refresh_seconds = refresh_seconds ) if metrics : document . with_metrics ( metrics ) document . with_element ( \"<br>\" ) for renderer in renderers : document . with_scripts ( renderer . SCRIPTS ) document . with_element ( renderer . generate_html ( html_path = output_path )) output_path . write_text ( document . embed (), encoding = \"utf8\" ) return output_file","title":"Html"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML","text":"Source code in dvc_render/html.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class HTML : SCRIPTS_PLACEHOLDER = \"scripts\" PLOTS_PLACEHOLDER = \"plot_divs\" PLOTS_PLACEHOLDER_FORMAT_STR = f \" {{ { PLOTS_PLACEHOLDER } }} \" REFRESH_PLACEHOLDER = \"refresh_tag\" REFRESH_TAG = '<meta http-equiv=\"refresh\" content=\" {} \">' def __init__ ( self , template : Optional [ str ] = None , refresh_seconds : Optional [ int ] = None , ): template = template or PAGE_HTML if self . PLOTS_PLACEHOLDER_FORMAT_STR not in template : raise MissingPlaceholderError ( self . PLOTS_PLACEHOLDER_FORMAT_STR ) self . template = template self . elements : List [ str ] = [] self . scripts : str = \"\" self . refresh_tag = \"\" if refresh_seconds is not None : self . refresh_tag = self . REFRESH_TAG . format ( refresh_seconds ) def with_metrics ( self , metrics : Dict [ str , Dict ]) -> \"HTML\" : \"Adds metrics element.\" header : List [ str ] = [] rows : List [ List [ str ]] = [] for _ , rev_data in metrics . items (): for _ , data in rev_data . items (): if not header : header . extend ( sorted ( data . keys ())) rows . append ([ data [ key ] for key in header ]) self . elements . append ( tabulate . tabulate ( rows , header , tablefmt = \"html\" )) return self def with_scripts ( self , scripts : str ) -> \"HTML\" : \"Extend scripts element.\" if scripts not in self . scripts : self . scripts += f \" \\n { scripts } \" return self def with_element ( self , html : str ) -> \"HTML\" : \"Adds custom html element.\" self . elements . append ( html ) return self def embed ( self ) -> str : \"Format HTML template with all elements.\" kwargs = { self . SCRIPTS_PLACEHOLDER : self . scripts , self . PLOTS_PLACEHOLDER : \" \\n \" . join ( self . elements ), self . REFRESH_PLACEHOLDER : self . refresh_tag , } return self . template . format ( ** kwargs )","title":"HTML"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML.embed","text":"Format HTML template with all elements. Source code in dvc_render/html.py 79 80 81 82 83 84 85 86 def embed ( self ) -> str : \"Format HTML template with all elements.\" kwargs = { self . SCRIPTS_PLACEHOLDER : self . scripts , self . PLOTS_PLACEHOLDER : \" \\n \" . join ( self . elements ), self . REFRESH_PLACEHOLDER : self . refresh_tag , } return self . template . format ( ** kwargs )","title":"embed()"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML.with_element","text":"Adds custom html element. Source code in dvc_render/html.py 74 75 76 77 def with_element ( self , html : str ) -> \"HTML\" : \"Adds custom html element.\" self . elements . append ( html ) return self","title":"with_element()"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML.with_metrics","text":"Adds metrics element. Source code in dvc_render/html.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def with_metrics ( self , metrics : Dict [ str , Dict ]) -> \"HTML\" : \"Adds metrics element.\" header : List [ str ] = [] rows : List [ List [ str ]] = [] for _ , rev_data in metrics . items (): for _ , data in rev_data . items (): if not header : header . extend ( sorted ( data . keys ())) rows . append ([ data [ key ] for key in header ]) self . elements . append ( tabulate . tabulate ( rows , header , tablefmt = \"html\" )) return self","title":"with_metrics()"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML.with_scripts","text":"Extend scripts element. Source code in dvc_render/html.py 68 69 70 71 72 def with_scripts ( self , scripts : str ) -> \"HTML\" : \"Extend scripts element.\" if scripts not in self . scripts : self . scripts += f \" \\n { scripts } \" return self","title":"with_scripts()"},{"location":"reference/dvc_render/html/#dvc_render.html.render_html","text":"User renderers to fill an HTML template and write to path. Source code in dvc_render/html.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def render_html ( renderers : List [ \"Renderer\" ], output_file : \"StrPath\" , metrics : Optional [ Dict [ str , Dict ]] = None , template_path : Optional [ \"StrPath\" ] = None , refresh_seconds : Optional [ int ] = None , ) -> \"StrPath\" : \"User renderers to fill an HTML template and write to path.\" output_path = Path ( output_file ) output_path . parent . mkdir ( exist_ok = True ) page_html = None if template_path : with open ( template_path , encoding = \"utf-8\" ) as fobj : page_html = fobj . read () document = HTML ( page_html , refresh_seconds = refresh_seconds ) if metrics : document . with_metrics ( metrics ) document . with_element ( \"<br>\" ) for renderer in renderers : document . with_scripts ( renderer . SCRIPTS ) document . with_element ( renderer . generate_html ( html_path = output_path )) output_path . write_text ( document . embed (), encoding = \"utf8\" ) return output_file","title":"render_html()"},{"location":"reference/dvc_render/image/","text":"ImageRenderer Bases: Renderer Renderer for image plots. Source code in dvc_render/image.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class ImageRenderer ( Renderer ): \"\"\"Renderer for image plots.\"\"\" TYPE = \"image\" DIV = \"\"\" <div id=\" {id} \" style=\"border:1px solid black;text-align:center; white-space: nowrap;overflow-y:hidden;\"> {partial} </div>\"\"\" TITLE_FIELD = \"rev\" SRC_FIELD = \"src\" SCRIPTS = \"\" EXTENSIONS = { \".jpg\" , \".jpeg\" , \".gif\" , \".png\" } def partial_html ( self , html_path = None , ** kwargs ) -> str : div_content = [] for datapoint in self . datapoints : src = datapoint [ self . SRC_FIELD ] if ( not src . startswith ( \"data:image;base64\" ) and os . path . isabs ( src ) and html_path ): src = os . path . relpath ( src , os . path . dirname ( html_path )) div_content . append ( f \"\"\" <div style=\"border:1px dotted black;margin:2px;display: inline-block; overflow:hidden;margin-left:8px;\"> <p> { datapoint [ self . TITLE_FIELD ] } </p> <img src=\" { src } \"> </div> \"\"\" ) if div_content : div_content . insert ( 0 , f \"<p> { self . name } </p>\" ) return \" \\n \" . join ( div_content ) return \"\"","title":"Image"},{"location":"reference/dvc_render/image/#dvc_render.image.ImageRenderer","text":"Bases: Renderer Renderer for image plots. Source code in dvc_render/image.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class ImageRenderer ( Renderer ): \"\"\"Renderer for image plots.\"\"\" TYPE = \"image\" DIV = \"\"\" <div id=\" {id} \" style=\"border:1px solid black;text-align:center; white-space: nowrap;overflow-y:hidden;\"> {partial} </div>\"\"\" TITLE_FIELD = \"rev\" SRC_FIELD = \"src\" SCRIPTS = \"\" EXTENSIONS = { \".jpg\" , \".jpeg\" , \".gif\" , \".png\" } def partial_html ( self , html_path = None , ** kwargs ) -> str : div_content = [] for datapoint in self . datapoints : src = datapoint [ self . SRC_FIELD ] if ( not src . startswith ( \"data:image;base64\" ) and os . path . isabs ( src ) and html_path ): src = os . path . relpath ( src , os . path . dirname ( html_path )) div_content . append ( f \"\"\" <div style=\"border:1px dotted black;margin:2px;display: inline-block; overflow:hidden;margin-left:8px;\"> <p> { datapoint [ self . TITLE_FIELD ] } </p> <img src=\" { src } \"> </div> \"\"\" ) if div_content : div_content . insert ( 0 , f \"<p> { self . name } </p>\" ) return \" \\n \" . join ( div_content ) return \"\"","title":"ImageRenderer"},{"location":"reference/dvc_render/plotly/","text":"ParallelCoordinatesRenderer Bases: Renderer Renderer for Parallel Coordinates plot. Using Plotly. Source code in dvc_render/plotly.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class ParallelCoordinatesRenderer ( Renderer ): \"\"\" Renderer for Parallel Coordinates plot. Using Plotly. \"\"\" TYPE = \"plotly\" DIV = \"\"\" <div id = \" {id} \"> <script type = \"text/javascript\"> var plotly_data = {partial} ; Plotly.newPlot(\" {id} \", plotly_data.data, plotly_data.layout); </script> </div> \"\"\" EXTENSIONS = { \".json\" } SCRIPTS = \"\"\" <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script> \"\"\" # pylint: disable=W0231 def __init__ ( self , datapoints , name = \"pcp\" , color_by : Optional [ str ] = None , fill_value : str = \"\" , ): self . datapoints = datapoints self . color_by = color_by self . name = name self . fill_value = fill_value def partial_html ( self , ** kwargs ) -> str : return json . dumps ( self . _get_plotly_data ()) def _get_plotly_data ( self ): tabular_dict = defaultdict ( list ) for row in self . datapoints : for col_name , value in row . items (): tabular_dict [ col_name ] . append ( str ( value )) trace : Dict [ str , Any ] = { \"type\" : \"parcoords\" , \"dimensions\" : []} for label , values in tabular_dict . items (): is_categorical = False try : float_values = [ float ( x ) if x != self . fill_value else None for x in values ] except ValueError : is_categorical = True if is_categorical : non_missing = [ x for x in values if x != self . fill_value ] unique_values = sorted ( set ( non_missing )) unique_values . append ( self . fill_value ) dummy_values = [ unique_values . index ( x ) for x in values ] values = [ x if x != self . fill_value else \"Missing\" for x in values ] trace [ \"dimensions\" ] . append ( { \"label\" : label , \"values\" : dummy_values , \"tickvals\" : dummy_values , \"ticktext\" : values , } ) else : trace [ \"dimensions\" ] . append ( { \"label\" : label , \"values\" : float_values } ) if label == self . color_by : trace [ \"line\" ] = { \"color\" : dummy_values if is_categorical else float_values , \"showscale\" : True , \"colorbar\" : { \"title\" : self . color_by }, } if is_categorical : trace [ \"line\" ][ \"colorbar\" ][ \"tickmode\" ] = \"array\" trace [ \"line\" ][ \"colorbar\" ][ \"tickvals\" ] = dummy_values trace [ \"line\" ][ \"colorbar\" ][ \"ticktext\" ] = values return { \"data\" : [ trace ], \"layout\" : {}}","title":"Plotly"},{"location":"reference/dvc_render/plotly/#dvc_render.plotly.ParallelCoordinatesRenderer","text":"Bases: Renderer Renderer for Parallel Coordinates plot. Using Plotly. Source code in dvc_render/plotly.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class ParallelCoordinatesRenderer ( Renderer ): \"\"\" Renderer for Parallel Coordinates plot. Using Plotly. \"\"\" TYPE = \"plotly\" DIV = \"\"\" <div id = \" {id} \"> <script type = \"text/javascript\"> var plotly_data = {partial} ; Plotly.newPlot(\" {id} \", plotly_data.data, plotly_data.layout); </script> </div> \"\"\" EXTENSIONS = { \".json\" } SCRIPTS = \"\"\" <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script> \"\"\" # pylint: disable=W0231 def __init__ ( self , datapoints , name = \"pcp\" , color_by : Optional [ str ] = None , fill_value : str = \"\" , ): self . datapoints = datapoints self . color_by = color_by self . name = name self . fill_value = fill_value def partial_html ( self , ** kwargs ) -> str : return json . dumps ( self . _get_plotly_data ()) def _get_plotly_data ( self ): tabular_dict = defaultdict ( list ) for row in self . datapoints : for col_name , value in row . items (): tabular_dict [ col_name ] . append ( str ( value )) trace : Dict [ str , Any ] = { \"type\" : \"parcoords\" , \"dimensions\" : []} for label , values in tabular_dict . items (): is_categorical = False try : float_values = [ float ( x ) if x != self . fill_value else None for x in values ] except ValueError : is_categorical = True if is_categorical : non_missing = [ x for x in values if x != self . fill_value ] unique_values = sorted ( set ( non_missing )) unique_values . append ( self . fill_value ) dummy_values = [ unique_values . index ( x ) for x in values ] values = [ x if x != self . fill_value else \"Missing\" for x in values ] trace [ \"dimensions\" ] . append ( { \"label\" : label , \"values\" : dummy_values , \"tickvals\" : dummy_values , \"ticktext\" : values , } ) else : trace [ \"dimensions\" ] . append ( { \"label\" : label , \"values\" : float_values } ) if label == self . color_by : trace [ \"line\" ] = { \"color\" : dummy_values if is_categorical else float_values , \"showscale\" : True , \"colorbar\" : { \"title\" : self . color_by }, } if is_categorical : trace [ \"line\" ][ \"colorbar\" ][ \"tickmode\" ] = \"array\" trace [ \"line\" ][ \"colorbar\" ][ \"tickvals\" ] = dummy_values trace [ \"line\" ][ \"colorbar\" ][ \"ticktext\" ] = values return { \"data\" : [ trace ], \"layout\" : {}}","title":"ParallelCoordinatesRenderer"},{"location":"reference/dvc_render/vega/","text":"VegaRenderer Bases: Renderer Renderer for vega plots. Source code in dvc_render/vega.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class VegaRenderer ( Renderer ): \"\"\"Renderer for vega plots.\"\"\" TYPE = \"vega\" DIV = \"\"\" <div id = \" {id} \"> <script type = \"text/javascript\"> var spec = {partial} ; vegaEmbed('# {id} ', spec); </script> </div> \"\"\" SCRIPTS = \"\"\" <script src=\"https://cdn.jsdelivr.net/npm/vega@5.20.2\"></script> <script src=\"https://cdn.jsdelivr.net/npm/vega-lite@5.2.0\"></script> <script src=\"https://cdn.jsdelivr.net/npm/vega-embed@6.18.2\"></script> \"\"\" EXTENSIONS = { \".yml\" , \".yaml\" , \".json\" , \".csv\" , \".tsv\" } def __init__ ( self , datapoints : List , name : str , ** properties ): super () . __init__ ( datapoints , name , ** properties ) self . template = get_template ( self . properties . get ( \"template\" , None ), self . properties . get ( \"template_dir\" , None ), ) def get_filled_template ( self , skip_anchors : Optional [ List [ str ]] = None , strict : bool = True ) -> str : \"\"\"Returns a functional vega specification\"\"\" if not self . datapoints : return \"\" if skip_anchors is None : skip_anchors = [] content = deepcopy ( self . template . content ) if strict : if self . properties . get ( \"x\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"x\" ) ) if self . properties . get ( \"y\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"y\" ) ) self . properties . setdefault ( \"title\" , \"\" ) self . properties . setdefault ( \"x_label\" , self . properties . get ( \"x\" )) self . properties . setdefault ( \"y_label\" , self . properties . get ( \"y\" )) self . properties . setdefault ( \"data\" , self . datapoints ) names = [ \"title\" , \"x\" , \"y\" , \"x_label\" , \"y_label\" , \"data\" ] for name in names : if name in skip_anchors : continue value = self . properties . get ( name ) if value is None : continue if name == \"data\" : if self . template . anchor_str ( name ) not in self . template . content : anchor = self . template . anchor ( name ) raise BadTemplateError ( f \"Template ' { self . template . name } ' \" f \"is not using ' { anchor } ' anchor\" ) content = self . template . fill_anchor ( content , name , value ) return content def partial_html ( self , ** kwargs ) -> str : return self . get_filled_template () get_filled_template ( skip_anchors = None , strict = True ) Returns a functional vega specification Source code in dvc_render/vega.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def get_filled_template ( self , skip_anchors : Optional [ List [ str ]] = None , strict : bool = True ) -> str : \"\"\"Returns a functional vega specification\"\"\" if not self . datapoints : return \"\" if skip_anchors is None : skip_anchors = [] content = deepcopy ( self . template . content ) if strict : if self . properties . get ( \"x\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"x\" ) ) if self . properties . get ( \"y\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"y\" ) ) self . properties . setdefault ( \"title\" , \"\" ) self . properties . setdefault ( \"x_label\" , self . properties . get ( \"x\" )) self . properties . setdefault ( \"y_label\" , self . properties . get ( \"y\" )) self . properties . setdefault ( \"data\" , self . datapoints ) names = [ \"title\" , \"x\" , \"y\" , \"x_label\" , \"y_label\" , \"data\" ] for name in names : if name in skip_anchors : continue value = self . properties . get ( name ) if value is None : continue if name == \"data\" : if self . template . anchor_str ( name ) not in self . template . content : anchor = self . template . anchor ( name ) raise BadTemplateError ( f \"Template ' { self . template . name } ' \" f \"is not using ' { anchor } ' anchor\" ) content = self . template . fill_anchor ( content , name , value ) return content","title":"Vega"},{"location":"reference/dvc_render/vega/#dvc_render.vega.VegaRenderer","text":"Bases: Renderer Renderer for vega plots. Source code in dvc_render/vega.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class VegaRenderer ( Renderer ): \"\"\"Renderer for vega plots.\"\"\" TYPE = \"vega\" DIV = \"\"\" <div id = \" {id} \"> <script type = \"text/javascript\"> var spec = {partial} ; vegaEmbed('# {id} ', spec); </script> </div> \"\"\" SCRIPTS = \"\"\" <script src=\"https://cdn.jsdelivr.net/npm/vega@5.20.2\"></script> <script src=\"https://cdn.jsdelivr.net/npm/vega-lite@5.2.0\"></script> <script src=\"https://cdn.jsdelivr.net/npm/vega-embed@6.18.2\"></script> \"\"\" EXTENSIONS = { \".yml\" , \".yaml\" , \".json\" , \".csv\" , \".tsv\" } def __init__ ( self , datapoints : List , name : str , ** properties ): super () . __init__ ( datapoints , name , ** properties ) self . template = get_template ( self . properties . get ( \"template\" , None ), self . properties . get ( \"template_dir\" , None ), ) def get_filled_template ( self , skip_anchors : Optional [ List [ str ]] = None , strict : bool = True ) -> str : \"\"\"Returns a functional vega specification\"\"\" if not self . datapoints : return \"\" if skip_anchors is None : skip_anchors = [] content = deepcopy ( self . template . content ) if strict : if self . properties . get ( \"x\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"x\" ) ) if self . properties . get ( \"y\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"y\" ) ) self . properties . setdefault ( \"title\" , \"\" ) self . properties . setdefault ( \"x_label\" , self . properties . get ( \"x\" )) self . properties . setdefault ( \"y_label\" , self . properties . get ( \"y\" )) self . properties . setdefault ( \"data\" , self . datapoints ) names = [ \"title\" , \"x\" , \"y\" , \"x_label\" , \"y_label\" , \"data\" ] for name in names : if name in skip_anchors : continue value = self . properties . get ( name ) if value is None : continue if name == \"data\" : if self . template . anchor_str ( name ) not in self . template . content : anchor = self . template . anchor ( name ) raise BadTemplateError ( f \"Template ' { self . template . name } ' \" f \"is not using ' { anchor } ' anchor\" ) content = self . template . fill_anchor ( content , name , value ) return content def partial_html ( self , ** kwargs ) -> str : return self . get_filled_template ()","title":"VegaRenderer"},{"location":"reference/dvc_render/vega/#dvc_render.vega.VegaRenderer.get_filled_template","text":"Returns a functional vega specification Source code in dvc_render/vega.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def get_filled_template ( self , skip_anchors : Optional [ List [ str ]] = None , strict : bool = True ) -> str : \"\"\"Returns a functional vega specification\"\"\" if not self . datapoints : return \"\" if skip_anchors is None : skip_anchors = [] content = deepcopy ( self . template . content ) if strict : if self . properties . get ( \"x\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"x\" ) ) if self . properties . get ( \"y\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"y\" ) ) self . properties . setdefault ( \"title\" , \"\" ) self . properties . setdefault ( \"x_label\" , self . properties . get ( \"x\" )) self . properties . setdefault ( \"y_label\" , self . properties . get ( \"y\" )) self . properties . setdefault ( \"data\" , self . datapoints ) names = [ \"title\" , \"x\" , \"y\" , \"x_label\" , \"y_label\" , \"data\" ] for name in names : if name in skip_anchors : continue value = self . properties . get ( name ) if value is None : continue if name == \"data\" : if self . template . anchor_str ( name ) not in self . template . content : anchor = self . template . anchor ( name ) raise BadTemplateError ( f \"Template ' { self . template . name } ' \" f \"is not using ' { anchor } ' anchor\" ) content = self . template . fill_anchor ( content , name , value ) return content","title":"get_filled_template()"},{"location":"reference/dvc_render/vega_templates/","text":"Template Source code in dvc_render/vega_templates.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class Template : INDENT = 4 SEPARATORS = ( \",\" , \": \" ) EXTENSION = \".json\" ANCHOR = \"<DVC_METRIC_ {} >\" DEFAULT_CONTENT : Optional [ Dict [ str , Any ]] = None DEFAULT_NAME : Optional [ str ] = None def __init__ ( self , content = None , name = None ): if content : self . content = content else : self . content = ( json . dumps ( self . DEFAULT_CONTENT , indent = self . INDENT , separators = self . SEPARATORS , ) + \" \\n \" ) self . name = name or self . DEFAULT_NAME assert self . content and self . name self . filename = Path ( self . name ) . with_suffix ( self . EXTENSION ) @classmethod def anchor ( cls , name ): \"Get ANCHOR formatted with name.\" return cls . ANCHOR . format ( name . upper ()) def has_anchor ( self , name ) -> bool : \"Check if ANCHOR formatted with name is in content.\" return self . anchor_str ( name ) in self . content @classmethod def fill_anchor ( cls , content , name , value ) -> str : \"Replace anchor `name` with `value` in content.\" value_str = json . dumps ( value , indent = cls . INDENT , separators = cls . SEPARATORS , sort_keys = True ) return content . replace ( cls . anchor_str ( name ), value_str ) @classmethod def anchor_str ( cls , name ) -> str : \"Get string wrapping ANCHOR formatted with name.\" return f '\" { cls . anchor ( name ) } \"' @staticmethod def check_field_exists ( data , field ): \"Raise NoFieldInDataError if `field` not in `data`.\" if not any ( field in row for row in data ): raise NoFieldInDataError ( field ) anchor ( name ) classmethod Get ANCHOR formatted with name. Source code in dvc_render/vega_templates.py 58 59 60 61 @classmethod def anchor ( cls , name ): \"Get ANCHOR formatted with name.\" return cls . ANCHOR . format ( name . upper ()) anchor_str ( name ) classmethod Get string wrapping ANCHOR formatted with name. Source code in dvc_render/vega_templates.py 75 76 77 78 @classmethod def anchor_str ( cls , name ) -> str : \"Get string wrapping ANCHOR formatted with name.\" return f '\" { cls . anchor ( name ) } \"' check_field_exists ( data , field ) staticmethod Raise NoFieldInDataError if field not in data . Source code in dvc_render/vega_templates.py 80 81 82 83 84 @staticmethod def check_field_exists ( data , field ): \"Raise NoFieldInDataError if `field` not in `data`.\" if not any ( field in row for row in data ): raise NoFieldInDataError ( field ) fill_anchor ( content , name , value ) classmethod Replace anchor name with value in content. Source code in dvc_render/vega_templates.py 67 68 69 70 71 72 73 @classmethod def fill_anchor ( cls , content , name , value ) -> str : \"Replace anchor `name` with `value` in content.\" value_str = json . dumps ( value , indent = cls . INDENT , separators = cls . SEPARATORS , sort_keys = True ) return content . replace ( cls . anchor_str ( name ), value_str ) has_anchor ( name ) Check if ANCHOR formatted with name is in content. Source code in dvc_render/vega_templates.py 63 64 65 def has_anchor ( self , name ) -> bool : \"Check if ANCHOR formatted with name is in content.\" return self . anchor_str ( name ) in self . content dump_templates ( output , targets = None ) Write TEMPLATES in .json format to output . Source code in dvc_render/vega_templates.py 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 def dump_templates ( output : \"StrPath\" , targets : Optional [ List ] = None ) -> None : \"Write TEMPLATES in `.json` format to `output`.\" output = Path ( output ) output . mkdir ( exist_ok = True ) if targets : templates = [ template for template in TEMPLATES if template . DEFAULT_NAME in targets ] else : templates = TEMPLATES for template_cls in templates : template = template_cls () path = output / template . filename if path . exists (): content = path . read_text ( encoding = \"utf-8\" ) if content != template . content : raise TemplateContentDoesNotMatch ( template . DEFAULT_NAME or \"\" , path ) else : path . write_text ( template . content , encoding = \"utf-8\" ) get_template ( template = None , template_dir = None ) Return template instance based on given template arg. If template is already an instance, return it. If template is None, return default linear template. If template is a path, will try to find it as absolute path or inside template_dir. If template matches one of the DEFAULT_NAMEs in TEMPLATES, return an instance of the one matching. Source code in dvc_render/vega_templates.py 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 def get_template ( template : Union [ Optional [ str ], Template ] = None , template_dir : Optional [ str ] = None , ) -> Template : \"\"\"Return template instance based on given template arg. If template is already an instance, return it. If template is None, return default `linear` template. If template is a path, will try to find it as absolute path or inside template_dir. If template matches one of the DEFAULT_NAMEs in TEMPLATES, return an instance of the one matching. \"\"\" if isinstance ( template , Template ): return template if template is None : template = \"linear\" template_path = _find_template ( template , template_dir ) if template_path : with open ( template_path , \"r\" , encoding = \"utf-8\" ) as f : content = f . read () return Template ( content , name = template ) for template_cls in TEMPLATES : if template_cls . DEFAULT_NAME == template : return template_cls () raise TemplateNotFoundError ( template )","title":"Vega templates"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template","text":"Source code in dvc_render/vega_templates.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class Template : INDENT = 4 SEPARATORS = ( \",\" , \": \" ) EXTENSION = \".json\" ANCHOR = \"<DVC_METRIC_ {} >\" DEFAULT_CONTENT : Optional [ Dict [ str , Any ]] = None DEFAULT_NAME : Optional [ str ] = None def __init__ ( self , content = None , name = None ): if content : self . content = content else : self . content = ( json . dumps ( self . DEFAULT_CONTENT , indent = self . INDENT , separators = self . SEPARATORS , ) + \" \\n \" ) self . name = name or self . DEFAULT_NAME assert self . content and self . name self . filename = Path ( self . name ) . with_suffix ( self . EXTENSION ) @classmethod def anchor ( cls , name ): \"Get ANCHOR formatted with name.\" return cls . ANCHOR . format ( name . upper ()) def has_anchor ( self , name ) -> bool : \"Check if ANCHOR formatted with name is in content.\" return self . anchor_str ( name ) in self . content @classmethod def fill_anchor ( cls , content , name , value ) -> str : \"Replace anchor `name` with `value` in content.\" value_str = json . dumps ( value , indent = cls . INDENT , separators = cls . SEPARATORS , sort_keys = True ) return content . replace ( cls . anchor_str ( name ), value_str ) @classmethod def anchor_str ( cls , name ) -> str : \"Get string wrapping ANCHOR formatted with name.\" return f '\" { cls . anchor ( name ) } \"' @staticmethod def check_field_exists ( data , field ): \"Raise NoFieldInDataError if `field` not in `data`.\" if not any ( field in row for row in data ): raise NoFieldInDataError ( field )","title":"Template"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.anchor","text":"Get ANCHOR formatted with name. Source code in dvc_render/vega_templates.py 58 59 60 61 @classmethod def anchor ( cls , name ): \"Get ANCHOR formatted with name.\" return cls . ANCHOR . format ( name . upper ())","title":"anchor()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.anchor_str","text":"Get string wrapping ANCHOR formatted with name. Source code in dvc_render/vega_templates.py 75 76 77 78 @classmethod def anchor_str ( cls , name ) -> str : \"Get string wrapping ANCHOR formatted with name.\" return f '\" { cls . anchor ( name ) } \"'","title":"anchor_str()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.check_field_exists","text":"Raise NoFieldInDataError if field not in data . Source code in dvc_render/vega_templates.py 80 81 82 83 84 @staticmethod def check_field_exists ( data , field ): \"Raise NoFieldInDataError if `field` not in `data`.\" if not any ( field in row for row in data ): raise NoFieldInDataError ( field )","title":"check_field_exists()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.fill_anchor","text":"Replace anchor name with value in content. Source code in dvc_render/vega_templates.py 67 68 69 70 71 72 73 @classmethod def fill_anchor ( cls , content , name , value ) -> str : \"Replace anchor `name` with `value` in content.\" value_str = json . dumps ( value , indent = cls . INDENT , separators = cls . SEPARATORS , sort_keys = True ) return content . replace ( cls . anchor_str ( name ), value_str )","title":"fill_anchor()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.has_anchor","text":"Check if ANCHOR formatted with name is in content. Source code in dvc_render/vega_templates.py 63 64 65 def has_anchor ( self , name ) -> bool : \"Check if ANCHOR formatted with name is in content.\" return self . anchor_str ( name ) in self . content","title":"has_anchor()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.dump_templates","text":"Write TEMPLATES in .json format to output . Source code in dvc_render/vega_templates.py 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 def dump_templates ( output : \"StrPath\" , targets : Optional [ List ] = None ) -> None : \"Write TEMPLATES in `.json` format to `output`.\" output = Path ( output ) output . mkdir ( exist_ok = True ) if targets : templates = [ template for template in TEMPLATES if template . DEFAULT_NAME in targets ] else : templates = TEMPLATES for template_cls in templates : template = template_cls () path = output / template . filename if path . exists (): content = path . read_text ( encoding = \"utf-8\" ) if content != template . content : raise TemplateContentDoesNotMatch ( template . DEFAULT_NAME or \"\" , path ) else : path . write_text ( template . content , encoding = \"utf-8\" )","title":"dump_templates()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.get_template","text":"Return template instance based on given template arg. If template is already an instance, return it. If template is None, return default linear template. If template is a path, will try to find it as absolute path or inside template_dir. If template matches one of the DEFAULT_NAMEs in TEMPLATES, return an instance of the one matching. Source code in dvc_render/vega_templates.py 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 def get_template ( template : Union [ Optional [ str ], Template ] = None , template_dir : Optional [ str ] = None , ) -> Template : \"\"\"Return template instance based on given template arg. If template is already an instance, return it. If template is None, return default `linear` template. If template is a path, will try to find it as absolute path or inside template_dir. If template matches one of the DEFAULT_NAMEs in TEMPLATES, return an instance of the one matching. \"\"\" if isinstance ( template , Template ): return template if template is None : template = \"linear\" template_path = _find_template ( template , template_dir ) if template_path : with open ( template_path , \"r\" , encoding = \"utf-8\" ) as f : content = f . read () return Template ( content , name = template ) for template_cls in TEMPLATES : if template_cls . DEFAULT_NAME == template : return template_cls () raise TemplateNotFoundError ( template )","title":"get_template()"}]}