{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Dvc Render API Reference","title":"Welcome to Dvc Render"},{"location":"#welcome-to-dvc-render","text":"API Reference","title":"Welcome to Dvc Render"},{"location":"reference/dvc_render/","text":"Library for rendering DVC plots","title":"Dvc render"},{"location":"reference/dvc_render/base/","text":"Renderer Bases: abc . ABC Base Renderer class Source code in dvc_render/base.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class Renderer ( abc . ABC ): \"\"\"Base Renderer class\"\"\" DIV = \"\"\" <div id=\" {id} \"> {partial} </div> \"\"\" EXTENSIONS : Iterable [ str ] = {} def __init__ ( self , datapoints : Dict , name : str , ** properties ): self . datapoints = datapoints self . name = name self . properties = properties @abc . abstractmethod def partial_html ( self ) -> str : \"\"\" Us this method to generate HTML content, to fill `{partial}` inside self.DIV. \"\"\" raise NotImplementedError @property @abc . abstractmethod def TYPE ( self ): # pylint: disable=missing-function-docstring raise NotImplementedError @property @abc . abstractmethod def SCRIPTS ( self ): # pylint: disable=missing-function-docstring raise NotImplementedError @staticmethod def remove_special_chars ( string : str ) -> str : \"Ensure string is valid HTML id.\" return string . translate ( { ord ( c ): \"_\" for c in r \"!@#$%^&*()[] {} ;,<>?\\/:.|`~=_+\" } ) def generate_html ( self ) -> str : \"Return `DIV` formatted with `partial_html`.\" partial = self . partial_html () div_id = self . remove_special_chars ( self . name ) div_id = f \"plot_ { div_id } \" return self . DIV . format ( id = div_id , partial = partial ) @classmethod def matches ( cls , filename , properties # pylint: disable=unused-argument ) -> bool : \"Check if the Renderer is suitable.\" return Path ( filename ) . suffix in cls . EXTENSIONS generate_html () Return DIV formatted with partial_html . Source code in dvc_render/base.py 52 53 54 55 56 57 58 59 def generate_html ( self ) -> str : \"Return `DIV` formatted with `partial_html`.\" partial = self . partial_html () div_id = self . remove_special_chars ( self . name ) div_id = f \"plot_ { div_id } \" return self . DIV . format ( id = div_id , partial = partial ) matches ( filename , properties ) classmethod Check if the Renderer is suitable. Source code in dvc_render/base.py 61 62 63 64 65 66 @classmethod def matches ( cls , filename , properties # pylint: disable=unused-argument ) -> bool : \"Check if the Renderer is suitable.\" return Path ( filename ) . suffix in cls . EXTENSIONS partial_html () abstract Us this method to generate HTML content, to fill {partial} inside self.DIV. Source code in dvc_render/base.py 27 28 29 30 31 32 33 @abc . abstractmethod def partial_html ( self ) -> str : \"\"\" Us this method to generate HTML content, to fill `{partial}` inside self.DIV. \"\"\" raise NotImplementedError remove_special_chars ( string ) staticmethod Ensure string is valid HTML id. Source code in dvc_render/base.py 45 46 47 48 49 50 @staticmethod def remove_special_chars ( string : str ) -> str : \"Ensure string is valid HTML id.\" return string . translate ( { ord ( c ): \"_\" for c in r \"!@#$%^&*()[] {} ;,<>?\\/:.|`~=_+\" } )","title":"Base"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer","text":"Bases: abc . ABC Base Renderer class Source code in dvc_render/base.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class Renderer ( abc . ABC ): \"\"\"Base Renderer class\"\"\" DIV = \"\"\" <div id=\" {id} \"> {partial} </div> \"\"\" EXTENSIONS : Iterable [ str ] = {} def __init__ ( self , datapoints : Dict , name : str , ** properties ): self . datapoints = datapoints self . name = name self . properties = properties @abc . abstractmethod def partial_html ( self ) -> str : \"\"\" Us this method to generate HTML content, to fill `{partial}` inside self.DIV. \"\"\" raise NotImplementedError @property @abc . abstractmethod def TYPE ( self ): # pylint: disable=missing-function-docstring raise NotImplementedError @property @abc . abstractmethod def SCRIPTS ( self ): # pylint: disable=missing-function-docstring raise NotImplementedError @staticmethod def remove_special_chars ( string : str ) -> str : \"Ensure string is valid HTML id.\" return string . translate ( { ord ( c ): \"_\" for c in r \"!@#$%^&*()[] {} ;,<>?\\/:.|`~=_+\" } ) def generate_html ( self ) -> str : \"Return `DIV` formatted with `partial_html`.\" partial = self . partial_html () div_id = self . remove_special_chars ( self . name ) div_id = f \"plot_ { div_id } \" return self . DIV . format ( id = div_id , partial = partial ) @classmethod def matches ( cls , filename , properties # pylint: disable=unused-argument ) -> bool : \"Check if the Renderer is suitable.\" return Path ( filename ) . suffix in cls . EXTENSIONS","title":"Renderer"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.generate_html","text":"Return DIV formatted with partial_html . Source code in dvc_render/base.py 52 53 54 55 56 57 58 59 def generate_html ( self ) -> str : \"Return `DIV` formatted with `partial_html`.\" partial = self . partial_html () div_id = self . remove_special_chars ( self . name ) div_id = f \"plot_ { div_id } \" return self . DIV . format ( id = div_id , partial = partial )","title":"generate_html()"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.matches","text":"Check if the Renderer is suitable. Source code in dvc_render/base.py 61 62 63 64 65 66 @classmethod def matches ( cls , filename , properties # pylint: disable=unused-argument ) -> bool : \"Check if the Renderer is suitable.\" return Path ( filename ) . suffix in cls . EXTENSIONS","title":"matches()"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.partial_html","text":"Us this method to generate HTML content, to fill {partial} inside self.DIV. Source code in dvc_render/base.py 27 28 29 30 31 32 33 @abc . abstractmethod def partial_html ( self ) -> str : \"\"\" Us this method to generate HTML content, to fill `{partial}` inside self.DIV. \"\"\" raise NotImplementedError","title":"partial_html()"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.remove_special_chars","text":"Ensure string is valid HTML id. Source code in dvc_render/base.py 45 46 47 48 49 50 @staticmethod def remove_special_chars ( string : str ) -> str : \"Ensure string is valid HTML id.\" return string . translate ( { ord ( c ): \"_\" for c in r \"!@#$%^&*()[] {} ;,<>?\\/:.|`~=_+\" } )","title":"remove_special_chars()"},{"location":"reference/dvc_render/exceptions/","text":"","title":"Exceptions"},{"location":"reference/dvc_render/html/","text":"HTML Source code in dvc_render/html.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class HTML : SCRIPTS_PLACEHOLDER = \"scripts\" PLOTS_PLACEHOLDER = \"plot_divs\" PLOTS_PLACEHOLDER_FORMAT_STR = f \" {{ { PLOTS_PLACEHOLDER } }} \" REFRESH_PLACEHOLDER = \"refresh_tag\" REFRESH_TAG = '<meta http-equiv=\"refresh\" content=\" {} \">' def __init__ ( self , template : Optional [ str ] = None , refresh_seconds : Optional [ int ] = None , ): template = template or PAGE_HTML if self . PLOTS_PLACEHOLDER_FORMAT_STR not in template : raise MissingPlaceholderError ( self . PLOTS_PLACEHOLDER_FORMAT_STR ) self . template = template self . elements : List [ str ] = [] self . scripts : str = \"\" self . refresh_tag = \"\" if refresh_seconds is not None : self . refresh_tag = self . REFRESH_TAG . format ( refresh_seconds ) def with_metrics ( self , metrics : Dict [ str , Dict ]) -> \"HTML\" : \"Adds metrics element.\" header : List [ str ] = [] rows : List [ List [ str ]] = [] for _ , rev_data in metrics . items (): for _ , data in rev_data . items (): if not header : header . extend ( sorted ( data . keys ())) rows . append ([ data [ key ] for key in header ]) self . elements . append ( tabulate . tabulate ( rows , header , tablefmt = \"html\" )) return self def with_scripts ( self , scripts : str ) -> \"HTML\" : \"Extend scripts element.\" if scripts not in self . scripts : self . scripts += f \" \\n { scripts } \" return self def with_element ( self , html : str ) -> \"HTML\" : \"Adds custom html element.\" self . elements . append ( html ) return self def embed ( self ) -> str : \"Format HTML template with all elements.\" kwargs = { self . SCRIPTS_PLACEHOLDER : self . scripts , self . PLOTS_PLACEHOLDER : \" \\n \" . join ( self . elements ), self . REFRESH_PLACEHOLDER : self . refresh_tag , } return self . template . format ( ** kwargs ) embed () Format HTML template with all elements. Source code in dvc_render/html.py 79 80 81 82 83 84 85 86 def embed ( self ) -> str : \"Format HTML template with all elements.\" kwargs = { self . SCRIPTS_PLACEHOLDER : self . scripts , self . PLOTS_PLACEHOLDER : \" \\n \" . join ( self . elements ), self . REFRESH_PLACEHOLDER : self . refresh_tag , } return self . template . format ( ** kwargs ) with_element ( html ) Adds custom html element. Source code in dvc_render/html.py 74 75 76 77 def with_element ( self , html : str ) -> \"HTML\" : \"Adds custom html element.\" self . elements . append ( html ) return self with_metrics ( metrics ) Adds metrics element. Source code in dvc_render/html.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def with_metrics ( self , metrics : Dict [ str , Dict ]) -> \"HTML\" : \"Adds metrics element.\" header : List [ str ] = [] rows : List [ List [ str ]] = [] for _ , rev_data in metrics . items (): for _ , data in rev_data . items (): if not header : header . extend ( sorted ( data . keys ())) rows . append ([ data [ key ] for key in header ]) self . elements . append ( tabulate . tabulate ( rows , header , tablefmt = \"html\" )) return self with_scripts ( scripts ) Extend scripts element. Source code in dvc_render/html.py 68 69 70 71 72 def with_scripts ( self , scripts : str ) -> \"HTML\" : \"Extend scripts element.\" if scripts not in self . scripts : self . scripts += f \" \\n { scripts } \" return self render_html ( renderers , output_file , metrics = None , template_path = None , refresh_seconds = None ) User renderers to fill an HTML template and write to path. Source code in dvc_render/html.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def render_html ( renderers : List [ \"Renderer\" ], output_file : \"StrPath\" , metrics : Optional [ Dict [ str , Dict ]] = None , template_path : Optional [ \"StrPath\" ] = None , refresh_seconds : Optional [ int ] = None , ) -> \"StrPath\" : \"User renderers to fill an HTML template and write to path.\" output_path = Path ( output_file ) output_path . parent . mkdir ( exist_ok = True ) page_html = None if template_path : with open ( template_path , encoding = \"utf-8\" ) as fobj : page_html = fobj . read () document = HTML ( page_html , refresh_seconds = refresh_seconds ) if metrics : document . with_metrics ( metrics ) document . with_element ( \"<br>\" ) for renderer in renderers : document . with_scripts ( renderer . SCRIPTS ) document . with_element ( renderer . generate_html ()) output_path . write_text ( document . embed (), encoding = \"utf8\" ) return output_file","title":"Html"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML","text":"Source code in dvc_render/html.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class HTML : SCRIPTS_PLACEHOLDER = \"scripts\" PLOTS_PLACEHOLDER = \"plot_divs\" PLOTS_PLACEHOLDER_FORMAT_STR = f \" {{ { PLOTS_PLACEHOLDER } }} \" REFRESH_PLACEHOLDER = \"refresh_tag\" REFRESH_TAG = '<meta http-equiv=\"refresh\" content=\" {} \">' def __init__ ( self , template : Optional [ str ] = None , refresh_seconds : Optional [ int ] = None , ): template = template or PAGE_HTML if self . PLOTS_PLACEHOLDER_FORMAT_STR not in template : raise MissingPlaceholderError ( self . PLOTS_PLACEHOLDER_FORMAT_STR ) self . template = template self . elements : List [ str ] = [] self . scripts : str = \"\" self . refresh_tag = \"\" if refresh_seconds is not None : self . refresh_tag = self . REFRESH_TAG . format ( refresh_seconds ) def with_metrics ( self , metrics : Dict [ str , Dict ]) -> \"HTML\" : \"Adds metrics element.\" header : List [ str ] = [] rows : List [ List [ str ]] = [] for _ , rev_data in metrics . items (): for _ , data in rev_data . items (): if not header : header . extend ( sorted ( data . keys ())) rows . append ([ data [ key ] for key in header ]) self . elements . append ( tabulate . tabulate ( rows , header , tablefmt = \"html\" )) return self def with_scripts ( self , scripts : str ) -> \"HTML\" : \"Extend scripts element.\" if scripts not in self . scripts : self . scripts += f \" \\n { scripts } \" return self def with_element ( self , html : str ) -> \"HTML\" : \"Adds custom html element.\" self . elements . append ( html ) return self def embed ( self ) -> str : \"Format HTML template with all elements.\" kwargs = { self . SCRIPTS_PLACEHOLDER : self . scripts , self . PLOTS_PLACEHOLDER : \" \\n \" . join ( self . elements ), self . REFRESH_PLACEHOLDER : self . refresh_tag , } return self . template . format ( ** kwargs )","title":"HTML"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML.embed","text":"Format HTML template with all elements. Source code in dvc_render/html.py 79 80 81 82 83 84 85 86 def embed ( self ) -> str : \"Format HTML template with all elements.\" kwargs = { self . SCRIPTS_PLACEHOLDER : self . scripts , self . PLOTS_PLACEHOLDER : \" \\n \" . join ( self . elements ), self . REFRESH_PLACEHOLDER : self . refresh_tag , } return self . template . format ( ** kwargs )","title":"embed()"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML.with_element","text":"Adds custom html element. Source code in dvc_render/html.py 74 75 76 77 def with_element ( self , html : str ) -> \"HTML\" : \"Adds custom html element.\" self . elements . append ( html ) return self","title":"with_element()"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML.with_metrics","text":"Adds metrics element. Source code in dvc_render/html.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def with_metrics ( self , metrics : Dict [ str , Dict ]) -> \"HTML\" : \"Adds metrics element.\" header : List [ str ] = [] rows : List [ List [ str ]] = [] for _ , rev_data in metrics . items (): for _ , data in rev_data . items (): if not header : header . extend ( sorted ( data . keys ())) rows . append ([ data [ key ] for key in header ]) self . elements . append ( tabulate . tabulate ( rows , header , tablefmt = \"html\" )) return self","title":"with_metrics()"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML.with_scripts","text":"Extend scripts element. Source code in dvc_render/html.py 68 69 70 71 72 def with_scripts ( self , scripts : str ) -> \"HTML\" : \"Extend scripts element.\" if scripts not in self . scripts : self . scripts += f \" \\n { scripts } \" return self","title":"with_scripts()"},{"location":"reference/dvc_render/html/#dvc_render.html.render_html","text":"User renderers to fill an HTML template and write to path. Source code in dvc_render/html.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def render_html ( renderers : List [ \"Renderer\" ], output_file : \"StrPath\" , metrics : Optional [ Dict [ str , Dict ]] = None , template_path : Optional [ \"StrPath\" ] = None , refresh_seconds : Optional [ int ] = None , ) -> \"StrPath\" : \"User renderers to fill an HTML template and write to path.\" output_path = Path ( output_file ) output_path . parent . mkdir ( exist_ok = True ) page_html = None if template_path : with open ( template_path , encoding = \"utf-8\" ) as fobj : page_html = fobj . read () document = HTML ( page_html , refresh_seconds = refresh_seconds ) if metrics : document . with_metrics ( metrics ) document . with_element ( \"<br>\" ) for renderer in renderers : document . with_scripts ( renderer . SCRIPTS ) document . with_element ( renderer . generate_html ()) output_path . write_text ( document . embed (), encoding = \"utf8\" ) return output_file","title":"render_html()"},{"location":"reference/dvc_render/image/","text":"ImageRenderer Bases: Renderer Renderer for image plots. Source code in dvc_render/image.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class ImageRenderer ( Renderer ): \"\"\"Renderer for image plots.\"\"\" TYPE = \"image\" DIV = \"\"\" <div id=\" {id} \" style=\"border:1px solid black;text-align:center; white-space: nowrap;overflow-y:hidden;\"> {partial} </div>\"\"\" TITLE_FIELD = \"rev\" SRC_FIELD = \"src\" SCRIPTS = \"\" EXTENSIONS = { \".jpg\" , \".jpeg\" , \".gif\" , \".png\" } def partial_html ( self ) -> str : div_content = [] for datapoint in self . datapoints : div_content . append ( f \"\"\" <div style=\"border:1px dotted black;margin:2px;display: inline-block; overflow:hidden;margin-left:8px;\"> <p> { datapoint [ self . TITLE_FIELD ] } </p> <img src=\" { datapoint [ self . SRC_FIELD ] } \"> </div> \"\"\" ) if div_content : div_content . insert ( 0 , f \"<p> { self . name } </p>\" ) return \" \\n \" . join ( div_content ) return \"\"","title":"Image"},{"location":"reference/dvc_render/image/#dvc_render.image.ImageRenderer","text":"Bases: Renderer Renderer for image plots. Source code in dvc_render/image.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class ImageRenderer ( Renderer ): \"\"\"Renderer for image plots.\"\"\" TYPE = \"image\" DIV = \"\"\" <div id=\" {id} \" style=\"border:1px solid black;text-align:center; white-space: nowrap;overflow-y:hidden;\"> {partial} </div>\"\"\" TITLE_FIELD = \"rev\" SRC_FIELD = \"src\" SCRIPTS = \"\" EXTENSIONS = { \".jpg\" , \".jpeg\" , \".gif\" , \".png\" } def partial_html ( self ) -> str : div_content = [] for datapoint in self . datapoints : div_content . append ( f \"\"\" <div style=\"border:1px dotted black;margin:2px;display: inline-block; overflow:hidden;margin-left:8px;\"> <p> { datapoint [ self . TITLE_FIELD ] } </p> <img src=\" { datapoint [ self . SRC_FIELD ] } \"> </div> \"\"\" ) if div_content : div_content . insert ( 0 , f \"<p> { self . name } </p>\" ) return \" \\n \" . join ( div_content ) return \"\"","title":"ImageRenderer"},{"location":"reference/dvc_render/plotly/","text":"ParallelCoordinatesRenderer Bases: Renderer Renderer for Parallel Coordinates plot. Using Plotly. Source code in dvc_render/plotly.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class ParallelCoordinatesRenderer ( Renderer ): \"\"\" Renderer for Parallel Coordinates plot. Using Plotly. \"\"\" TYPE = \"plotly\" DIV = \"\"\" <div id = \" {id} \"> <script type = \"text/javascript\"> var plotly_data = {partial} ; Plotly.newPlot(\" {id} \", plotly_data.data, plotly_data.layout); </script> </div> \"\"\" EXTENSIONS = { \".json\" } SCRIPTS = \"\"\" <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script> \"\"\" # pylint: disable=W0231 def __init__ ( self , datapoints , name = \"pcp\" , color_by : Optional [ str ] = None , fill_value : str = \"\" , ): self . datapoints = datapoints self . color_by = color_by self . name = name self . fill_value = fill_value def partial_html ( self ) -> str : return json . dumps ( self . _get_plotly_data ()) def _get_plotly_data ( self ): tabular_dict = defaultdict ( list ) for row in self . datapoints : for col_name , value in row . items (): tabular_dict [ col_name ] . append ( str ( value )) trace : Dict [ str , Any ] = { \"type\" : \"parcoords\" , \"dimensions\" : []} for label , values in tabular_dict . items (): is_categorical = False try : float_values = [ float ( x ) if x != self . fill_value else None for x in values ] except ValueError : is_categorical = True if is_categorical : non_missing = [ x for x in values if x != self . fill_value ] unique_values = sorted ( set ( non_missing )) unique_values . append ( self . fill_value ) dummy_values = [ unique_values . index ( x ) for x in values ] values = [ x if x != self . fill_value else \"Missing\" for x in values ] trace [ \"dimensions\" ] . append ( { \"label\" : label , \"values\" : dummy_values , \"tickvals\" : dummy_values , \"ticktext\" : values , } ) else : trace [ \"dimensions\" ] . append ( { \"label\" : label , \"values\" : float_values } ) if label == self . color_by : trace [ \"line\" ] = { \"color\" : dummy_values if is_categorical else float_values , \"showscale\" : True , \"colorbar\" : { \"title\" : self . color_by }, } if is_categorical : trace [ \"line\" ][ \"colorbar\" ][ \"tickmode\" ] = \"array\" trace [ \"line\" ][ \"colorbar\" ][ \"tickvals\" ] = dummy_values trace [ \"line\" ][ \"colorbar\" ][ \"ticktext\" ] = values return { \"data\" : [ trace ], \"layout\" : {}}","title":"Plotly"},{"location":"reference/dvc_render/plotly/#dvc_render.plotly.ParallelCoordinatesRenderer","text":"Bases: Renderer Renderer for Parallel Coordinates plot. Using Plotly. Source code in dvc_render/plotly.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class ParallelCoordinatesRenderer ( Renderer ): \"\"\" Renderer for Parallel Coordinates plot. Using Plotly. \"\"\" TYPE = \"plotly\" DIV = \"\"\" <div id = \" {id} \"> <script type = \"text/javascript\"> var plotly_data = {partial} ; Plotly.newPlot(\" {id} \", plotly_data.data, plotly_data.layout); </script> </div> \"\"\" EXTENSIONS = { \".json\" } SCRIPTS = \"\"\" <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script> \"\"\" # pylint: disable=W0231 def __init__ ( self , datapoints , name = \"pcp\" , color_by : Optional [ str ] = None , fill_value : str = \"\" , ): self . datapoints = datapoints self . color_by = color_by self . name = name self . fill_value = fill_value def partial_html ( self ) -> str : return json . dumps ( self . _get_plotly_data ()) def _get_plotly_data ( self ): tabular_dict = defaultdict ( list ) for row in self . datapoints : for col_name , value in row . items (): tabular_dict [ col_name ] . append ( str ( value )) trace : Dict [ str , Any ] = { \"type\" : \"parcoords\" , \"dimensions\" : []} for label , values in tabular_dict . items (): is_categorical = False try : float_values = [ float ( x ) if x != self . fill_value else None for x in values ] except ValueError : is_categorical = True if is_categorical : non_missing = [ x for x in values if x != self . fill_value ] unique_values = sorted ( set ( non_missing )) unique_values . append ( self . fill_value ) dummy_values = [ unique_values . index ( x ) for x in values ] values = [ x if x != self . fill_value else \"Missing\" for x in values ] trace [ \"dimensions\" ] . append ( { \"label\" : label , \"values\" : dummy_values , \"tickvals\" : dummy_values , \"ticktext\" : values , } ) else : trace [ \"dimensions\" ] . append ( { \"label\" : label , \"values\" : float_values } ) if label == self . color_by : trace [ \"line\" ] = { \"color\" : dummy_values if is_categorical else float_values , \"showscale\" : True , \"colorbar\" : { \"title\" : self . color_by }, } if is_categorical : trace [ \"line\" ][ \"colorbar\" ][ \"tickmode\" ] = \"array\" trace [ \"line\" ][ \"colorbar\" ][ \"tickvals\" ] = dummy_values trace [ \"line\" ][ \"colorbar\" ][ \"ticktext\" ] = values return { \"data\" : [ trace ], \"layout\" : {}}","title":"ParallelCoordinatesRenderer"},{"location":"reference/dvc_render/vega/","text":"VegaRenderer Bases: Renderer Renderer for vega plots. Source code in dvc_render/vega.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class VegaRenderer ( Renderer ): \"\"\"Renderer for vega plots.\"\"\" TYPE = \"vega\" DIV = \"\"\" <div id = \" {id} \"> <script type = \"text/javascript\"> var spec = {partial} ; vegaEmbed('# {id} ', spec); </script> </div> \"\"\" SCRIPTS = \"\"\" <script src=\"https://cdn.jsdelivr.net/npm/vega@5.20.2\"></script> <script src=\"https://cdn.jsdelivr.net/npm/vega-lite@5.1.0\"></script> <script src=\"https://cdn.jsdelivr.net/npm/vega-embed@6.18.2\"></script> \"\"\" EXTENSIONS = { \".yml\" , \".yaml\" , \".json\" , \".csv\" , \".tsv\" } def __init__ ( self , datapoints : Dict , name : str , ** properties ): super () . __init__ ( datapoints , name , ** properties ) self . template = get_template ( self . properties . get ( \"template\" , None ), self . properties . get ( \"template_dir\" , None ), ) def get_filled_template ( self , skip_anchors : Optional [ List [ str ]] = None , strict : bool = True ) -> str : \"\"\"Returns a functional vega specification\"\"\" if skip_anchors is None : skip_anchors = [] content = deepcopy ( self . template . content ) if strict : if self . properties . get ( \"x\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"x\" ) ) if self . properties . get ( \"y\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"y\" ) ) self . properties . setdefault ( \"title\" , \"\" ) self . properties . setdefault ( \"x_label\" , self . properties . get ( \"x\" )) self . properties . setdefault ( \"y_label\" , self . properties . get ( \"y\" )) self . properties . setdefault ( \"data\" , self . datapoints ) names = [ \"title\" , \"x\" , \"y\" , \"x_label\" , \"y_label\" , \"data\" ] for name in names : if name in skip_anchors : continue value = self . properties . get ( name ) if value is None : continue if name == \"data\" : if self . template . anchor_str ( name ) not in self . template . content : anchor = self . template . anchor ( name ) raise BadTemplateError ( f \"Template ' { self . template . name } ' \" f \"is not using ' { anchor } ' anchor\" ) content = self . template . fill_anchor ( content , name , value ) return content def partial_html ( self ) -> str : return self . get_filled_template () get_filled_template ( skip_anchors = None , strict = True ) Returns a functional vega specification Source code in dvc_render/vega.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def get_filled_template ( self , skip_anchors : Optional [ List [ str ]] = None , strict : bool = True ) -> str : \"\"\"Returns a functional vega specification\"\"\" if skip_anchors is None : skip_anchors = [] content = deepcopy ( self . template . content ) if strict : if self . properties . get ( \"x\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"x\" ) ) if self . properties . get ( \"y\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"y\" ) ) self . properties . setdefault ( \"title\" , \"\" ) self . properties . setdefault ( \"x_label\" , self . properties . get ( \"x\" )) self . properties . setdefault ( \"y_label\" , self . properties . get ( \"y\" )) self . properties . setdefault ( \"data\" , self . datapoints ) names = [ \"title\" , \"x\" , \"y\" , \"x_label\" , \"y_label\" , \"data\" ] for name in names : if name in skip_anchors : continue value = self . properties . get ( name ) if value is None : continue if name == \"data\" : if self . template . anchor_str ( name ) not in self . template . content : anchor = self . template . anchor ( name ) raise BadTemplateError ( f \"Template ' { self . template . name } ' \" f \"is not using ' { anchor } ' anchor\" ) content = self . template . fill_anchor ( content , name , value ) return content","title":"Vega"},{"location":"reference/dvc_render/vega/#dvc_render.vega.VegaRenderer","text":"Bases: Renderer Renderer for vega plots. Source code in dvc_render/vega.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class VegaRenderer ( Renderer ): \"\"\"Renderer for vega plots.\"\"\" TYPE = \"vega\" DIV = \"\"\" <div id = \" {id} \"> <script type = \"text/javascript\"> var spec = {partial} ; vegaEmbed('# {id} ', spec); </script> </div> \"\"\" SCRIPTS = \"\"\" <script src=\"https://cdn.jsdelivr.net/npm/vega@5.20.2\"></script> <script src=\"https://cdn.jsdelivr.net/npm/vega-lite@5.1.0\"></script> <script src=\"https://cdn.jsdelivr.net/npm/vega-embed@6.18.2\"></script> \"\"\" EXTENSIONS = { \".yml\" , \".yaml\" , \".json\" , \".csv\" , \".tsv\" } def __init__ ( self , datapoints : Dict , name : str , ** properties ): super () . __init__ ( datapoints , name , ** properties ) self . template = get_template ( self . properties . get ( \"template\" , None ), self . properties . get ( \"template_dir\" , None ), ) def get_filled_template ( self , skip_anchors : Optional [ List [ str ]] = None , strict : bool = True ) -> str : \"\"\"Returns a functional vega specification\"\"\" if skip_anchors is None : skip_anchors = [] content = deepcopy ( self . template . content ) if strict : if self . properties . get ( \"x\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"x\" ) ) if self . properties . get ( \"y\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"y\" ) ) self . properties . setdefault ( \"title\" , \"\" ) self . properties . setdefault ( \"x_label\" , self . properties . get ( \"x\" )) self . properties . setdefault ( \"y_label\" , self . properties . get ( \"y\" )) self . properties . setdefault ( \"data\" , self . datapoints ) names = [ \"title\" , \"x\" , \"y\" , \"x_label\" , \"y_label\" , \"data\" ] for name in names : if name in skip_anchors : continue value = self . properties . get ( name ) if value is None : continue if name == \"data\" : if self . template . anchor_str ( name ) not in self . template . content : anchor = self . template . anchor ( name ) raise BadTemplateError ( f \"Template ' { self . template . name } ' \" f \"is not using ' { anchor } ' anchor\" ) content = self . template . fill_anchor ( content , name , value ) return content def partial_html ( self ) -> str : return self . get_filled_template ()","title":"VegaRenderer"},{"location":"reference/dvc_render/vega/#dvc_render.vega.VegaRenderer.get_filled_template","text":"Returns a functional vega specification Source code in dvc_render/vega.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def get_filled_template ( self , skip_anchors : Optional [ List [ str ]] = None , strict : bool = True ) -> str : \"\"\"Returns a functional vega specification\"\"\" if skip_anchors is None : skip_anchors = [] content = deepcopy ( self . template . content ) if strict : if self . properties . get ( \"x\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"x\" ) ) if self . properties . get ( \"y\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"y\" ) ) self . properties . setdefault ( \"title\" , \"\" ) self . properties . setdefault ( \"x_label\" , self . properties . get ( \"x\" )) self . properties . setdefault ( \"y_label\" , self . properties . get ( \"y\" )) self . properties . setdefault ( \"data\" , self . datapoints ) names = [ \"title\" , \"x\" , \"y\" , \"x_label\" , \"y_label\" , \"data\" ] for name in names : if name in skip_anchors : continue value = self . properties . get ( name ) if value is None : continue if name == \"data\" : if self . template . anchor_str ( name ) not in self . template . content : anchor = self . template . anchor ( name ) raise BadTemplateError ( f \"Template ' { self . template . name } ' \" f \"is not using ' { anchor } ' anchor\" ) content = self . template . fill_anchor ( content , name , value ) return content","title":"get_filled_template()"},{"location":"reference/dvc_render/vega_templates/","text":"Template Source code in dvc_render/vega_templates.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class Template : INDENT = 4 SEPARATORS = ( \",\" , \": \" ) EXTENSION = \".json\" ANCHOR = \"<DVC_METRIC_ {} >\" DEFAULT_CONTENT : Optional [ Dict [ str , Any ]] = None DEFAULT_NAME : Optional [ str ] = None def __init__ ( self , content = None , name = None ): if content : self . content = content else : self . content = ( json . dumps ( self . DEFAULT_CONTENT , indent = self . INDENT , separators = self . SEPARATORS , ) + \" \\n \" ) self . name = name or self . DEFAULT_NAME assert self . content and self . name self . filename = Path ( self . name ) . with_suffix ( self . EXTENSION ) @classmethod def anchor ( cls , name ): \"Get ANCHOR formatted with name.\" return cls . ANCHOR . format ( name . upper ()) def has_anchor ( self , name ) -> bool : \"Check if ANCHOR formatted with name is in content.\" return self . anchor_str ( name ) in self . content @classmethod def fill_anchor ( cls , content , name , value ) -> str : \"Replace anchor `name` with `value` in content.\" value_str = json . dumps ( value , indent = cls . INDENT , separators = cls . SEPARATORS , sort_keys = True ) return content . replace ( cls . anchor_str ( name ), value_str ) @classmethod def anchor_str ( cls , name ) -> str : \"Get string wrapping ANCHOR formatted with name.\" return f '\" { cls . anchor ( name ) } \"' @staticmethod def check_field_exists ( data , field ): \"Raise NoFieldInDataError if `field` not in `data`.\" if not any ( field in row for row in data ): raise NoFieldInDataError ( field ) anchor ( name ) classmethod Get ANCHOR formatted with name. Source code in dvc_render/vega_templates.py 58 59 60 61 @classmethod def anchor ( cls , name ): \"Get ANCHOR formatted with name.\" return cls . ANCHOR . format ( name . upper ()) anchor_str ( name ) classmethod Get string wrapping ANCHOR formatted with name. Source code in dvc_render/vega_templates.py 75 76 77 78 @classmethod def anchor_str ( cls , name ) -> str : \"Get string wrapping ANCHOR formatted with name.\" return f '\" { cls . anchor ( name ) } \"' check_field_exists ( data , field ) staticmethod Raise NoFieldInDataError if field not in data . Source code in dvc_render/vega_templates.py 80 81 82 83 84 @staticmethod def check_field_exists ( data , field ): \"Raise NoFieldInDataError if `field` not in `data`.\" if not any ( field in row for row in data ): raise NoFieldInDataError ( field ) fill_anchor ( content , name , value ) classmethod Replace anchor name with value in content. Source code in dvc_render/vega_templates.py 67 68 69 70 71 72 73 @classmethod def fill_anchor ( cls , content , name , value ) -> str : \"Replace anchor `name` with `value` in content.\" value_str = json . dumps ( value , indent = cls . INDENT , separators = cls . SEPARATORS , sort_keys = True ) return content . replace ( cls . anchor_str ( name ), value_str ) has_anchor ( name ) Check if ANCHOR formatted with name is in content. Source code in dvc_render/vega_templates.py 63 64 65 def has_anchor ( self , name ) -> bool : \"Check if ANCHOR formatted with name is in content.\" return self . anchor_str ( name ) in self . content dump_templates ( output , targets = None ) Write TEMPLATES in .json format to output . Source code in dvc_render/vega_templates.py 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 def dump_templates ( output : \"StrPath\" , targets : Optional [ List ] = None ) -> None : \"Write TEMPLATES in `.json` format to `output`.\" output = Path ( output ) output . mkdir ( exist_ok = True ) if targets : templates = [ template for template in TEMPLATES if template . DEFAULT_NAME in targets ] else : templates = TEMPLATES for template_cls in templates : template = template_cls () path = output / template . filename if path . exists (): content = path . read_text ( encoding = \"utf-8\" ) if content != template . content : raise TemplateContentDoesNotMatch ( template . DEFAULT_NAME or \"\" , path ) else : path . write_text ( template . content , encoding = \"utf-8\" ) get_template ( template = None , template_dir = None ) Return template instance based on given template arg. If template is already an instance, return it. If template is None, return default linear template. If template is a path, will try to find it as absolute path or inside template_dir. If template matches one of the DEFAULT_NAMEs in TEMPLATES, return an instance of the one matching. Source code in dvc_render/vega_templates.py 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 def get_template ( template : Union [ Optional [ str ], Template ] = None , template_dir : Optional [ str ] = None , ) -> Template : \"\"\"Return template instance based on given template arg. If template is already an instance, return it. If template is None, return default `linear` template. If template is a path, will try to find it as absolute path or inside template_dir. If template matches one of the DEFAULT_NAMEs in TEMPLATES, return an instance of the one matching. \"\"\" if isinstance ( template , Template ): return template if template is None : template = \"linear\" template_path = _find_template ( template , template_dir ) if template_path : with open ( template_path , \"r\" , encoding = \"utf-8\" ) as f : content = f . read () return Template ( content , name = template ) for template_cls in TEMPLATES : if template_cls . DEFAULT_NAME == template : return template_cls () raise TemplateNotFoundError ( template )","title":"Vega templates"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template","text":"Source code in dvc_render/vega_templates.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class Template : INDENT = 4 SEPARATORS = ( \",\" , \": \" ) EXTENSION = \".json\" ANCHOR = \"<DVC_METRIC_ {} >\" DEFAULT_CONTENT : Optional [ Dict [ str , Any ]] = None DEFAULT_NAME : Optional [ str ] = None def __init__ ( self , content = None , name = None ): if content : self . content = content else : self . content = ( json . dumps ( self . DEFAULT_CONTENT , indent = self . INDENT , separators = self . SEPARATORS , ) + \" \\n \" ) self . name = name or self . DEFAULT_NAME assert self . content and self . name self . filename = Path ( self . name ) . with_suffix ( self . EXTENSION ) @classmethod def anchor ( cls , name ): \"Get ANCHOR formatted with name.\" return cls . ANCHOR . format ( name . upper ()) def has_anchor ( self , name ) -> bool : \"Check if ANCHOR formatted with name is in content.\" return self . anchor_str ( name ) in self . content @classmethod def fill_anchor ( cls , content , name , value ) -> str : \"Replace anchor `name` with `value` in content.\" value_str = json . dumps ( value , indent = cls . INDENT , separators = cls . SEPARATORS , sort_keys = True ) return content . replace ( cls . anchor_str ( name ), value_str ) @classmethod def anchor_str ( cls , name ) -> str : \"Get string wrapping ANCHOR formatted with name.\" return f '\" { cls . anchor ( name ) } \"' @staticmethod def check_field_exists ( data , field ): \"Raise NoFieldInDataError if `field` not in `data`.\" if not any ( field in row for row in data ): raise NoFieldInDataError ( field )","title":"Template"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.anchor","text":"Get ANCHOR formatted with name. Source code in dvc_render/vega_templates.py 58 59 60 61 @classmethod def anchor ( cls , name ): \"Get ANCHOR formatted with name.\" return cls . ANCHOR . format ( name . upper ())","title":"anchor()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.anchor_str","text":"Get string wrapping ANCHOR formatted with name. Source code in dvc_render/vega_templates.py 75 76 77 78 @classmethod def anchor_str ( cls , name ) -> str : \"Get string wrapping ANCHOR formatted with name.\" return f '\" { cls . anchor ( name ) } \"'","title":"anchor_str()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.check_field_exists","text":"Raise NoFieldInDataError if field not in data . Source code in dvc_render/vega_templates.py 80 81 82 83 84 @staticmethod def check_field_exists ( data , field ): \"Raise NoFieldInDataError if `field` not in `data`.\" if not any ( field in row for row in data ): raise NoFieldInDataError ( field )","title":"check_field_exists()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.fill_anchor","text":"Replace anchor name with value in content. Source code in dvc_render/vega_templates.py 67 68 69 70 71 72 73 @classmethod def fill_anchor ( cls , content , name , value ) -> str : \"Replace anchor `name` with `value` in content.\" value_str = json . dumps ( value , indent = cls . INDENT , separators = cls . SEPARATORS , sort_keys = True ) return content . replace ( cls . anchor_str ( name ), value_str )","title":"fill_anchor()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.has_anchor","text":"Check if ANCHOR formatted with name is in content. Source code in dvc_render/vega_templates.py 63 64 65 def has_anchor ( self , name ) -> bool : \"Check if ANCHOR formatted with name is in content.\" return self . anchor_str ( name ) in self . content","title":"has_anchor()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.dump_templates","text":"Write TEMPLATES in .json format to output . Source code in dvc_render/vega_templates.py 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 def dump_templates ( output : \"StrPath\" , targets : Optional [ List ] = None ) -> None : \"Write TEMPLATES in `.json` format to `output`.\" output = Path ( output ) output . mkdir ( exist_ok = True ) if targets : templates = [ template for template in TEMPLATES if template . DEFAULT_NAME in targets ] else : templates = TEMPLATES for template_cls in templates : template = template_cls () path = output / template . filename if path . exists (): content = path . read_text ( encoding = \"utf-8\" ) if content != template . content : raise TemplateContentDoesNotMatch ( template . DEFAULT_NAME or \"\" , path ) else : path . write_text ( template . content , encoding = \"utf-8\" )","title":"dump_templates()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.get_template","text":"Return template instance based on given template arg. If template is already an instance, return it. If template is None, return default linear template. If template is a path, will try to find it as absolute path or inside template_dir. If template matches one of the DEFAULT_NAMEs in TEMPLATES, return an instance of the one matching. Source code in dvc_render/vega_templates.py 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 def get_template ( template : Union [ Optional [ str ], Template ] = None , template_dir : Optional [ str ] = None , ) -> Template : \"\"\"Return template instance based on given template arg. If template is already an instance, return it. If template is None, return default `linear` template. If template is a path, will try to find it as absolute path or inside template_dir. If template matches one of the DEFAULT_NAMEs in TEMPLATES, return an instance of the one matching. \"\"\" if isinstance ( template , Template ): return template if template is None : template = \"linear\" template_path = _find_template ( template , template_dir ) if template_path : with open ( template_path , \"r\" , encoding = \"utf-8\" ) as f : content = f . read () return Template ( content , name = template ) for template_cls in TEMPLATES : if template_cls . DEFAULT_NAME == template : return template_cls () raise TemplateNotFoundError ( template )","title":"get_template()"}]}