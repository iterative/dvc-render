{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Dvc Render API Reference","title":"Welcome to Dvc Render"},{"location":"#welcome-to-dvc-render","text":"API Reference","title":"Welcome to Dvc Render"},{"location":"reference/dvc_render/","text":"Library for rendering DVC plots","title":"Dvc render"},{"location":"reference/dvc_render/base/","text":"Renderer Bases: abc . ABC Base Renderer class Source code in dvc_render/base.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class Renderer ( abc . ABC ): \"\"\"Base Renderer class\"\"\" DIV = \"\"\" <div id=\" {id} \"> {partial} </div> \"\"\" EXTENSIONS : Iterable [ str ] = {} def __init__ ( self , datapoints : List = None , name : str = None , ** properties ): self . datapoints = datapoints or [] self . name = name or \"\" self . properties = properties @abc . abstractmethod def partial_html ( self , ** kwargs ) -> str : \"\"\" Us this method to generate HTML content, to fill `{partial}` inside self.DIV. \"\"\" raise NotImplementedError @property @abc . abstractmethod def TYPE ( self ): # pylint: disable=missing-function-docstring raise NotImplementedError @property @abc . abstractmethod def SCRIPTS ( self ): # pylint: disable=missing-function-docstring raise NotImplementedError @staticmethod def remove_special_chars ( string : str ) -> str : \"Ensure string is valid HTML id.\" return string . translate ( { ord ( c ): \"_\" for c in r \"!@#$%^&*()[] {} ;,<>?\\/:.|`~=_+ \" } ) def generate_html ( self , html_path = None ) -> str : \"Return `DIV` formatted with `partial_html`.\" partial = self . partial_html ( html_path = html_path ) if partial : div_id = self . remove_special_chars ( self . name ) return self . DIV . format ( id = div_id , partial = partial ) return \"\" def generate_markdown ( self , report_path : Optional [ StrPath ] = None ) -> str : # pylint: disable=missing-function-docstring \"Generate a markdown element\" raise NotImplementedError @classmethod def matches ( cls , filename , properties # pylint: disable=unused-argument ) -> bool : \"Check if the Renderer is suitable.\" return Path ( filename ) . suffix in cls . EXTENSIONS generate_html ( html_path = None ) Return DIV formatted with partial_html . Source code in dvc_render/base.py 54 55 56 57 58 59 60 61 62 def generate_html ( self , html_path = None ) -> str : \"Return `DIV` formatted with `partial_html`.\" partial = self . partial_html ( html_path = html_path ) if partial : div_id = self . remove_special_chars ( self . name ) return self . DIV . format ( id = div_id , partial = partial ) return \"\" generate_markdown ( report_path = None ) Generate a markdown element Source code in dvc_render/base.py 64 65 66 67 68 def generate_markdown ( self , report_path : Optional [ StrPath ] = None ) -> str : # pylint: disable=missing-function-docstring \"Generate a markdown element\" raise NotImplementedError matches ( filename , properties ) classmethod Check if the Renderer is suitable. Source code in dvc_render/base.py 70 71 72 73 74 75 @classmethod def matches ( cls , filename , properties # pylint: disable=unused-argument ) -> bool : \"Check if the Renderer is suitable.\" return Path ( filename ) . suffix in cls . EXTENSIONS partial_html ( kwargs ) abstractmethod Us this method to generate HTML content, to fill {partial} inside self.DIV. Source code in dvc_render/base.py 29 30 31 32 33 34 35 @abc . abstractmethod def partial_html ( self , ** kwargs ) -> str : \"\"\" Us this method to generate HTML content, to fill `{partial}` inside self.DIV. \"\"\" raise NotImplementedError remove_special_chars ( string ) staticmethod Ensure string is valid HTML id. Source code in dvc_render/base.py 47 48 49 50 51 52 @staticmethod def remove_special_chars ( string : str ) -> str : \"Ensure string is valid HTML id.\" return string . translate ( { ord ( c ): \"_\" for c in r \"!@#$%^&*()[] {} ;,<>?\\/:.|`~=_+ \" } )","title":"Base"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer","text":"Bases: abc . ABC Base Renderer class Source code in dvc_render/base.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class Renderer ( abc . ABC ): \"\"\"Base Renderer class\"\"\" DIV = \"\"\" <div id=\" {id} \"> {partial} </div> \"\"\" EXTENSIONS : Iterable [ str ] = {} def __init__ ( self , datapoints : List = None , name : str = None , ** properties ): self . datapoints = datapoints or [] self . name = name or \"\" self . properties = properties @abc . abstractmethod def partial_html ( self , ** kwargs ) -> str : \"\"\" Us this method to generate HTML content, to fill `{partial}` inside self.DIV. \"\"\" raise NotImplementedError @property @abc . abstractmethod def TYPE ( self ): # pylint: disable=missing-function-docstring raise NotImplementedError @property @abc . abstractmethod def SCRIPTS ( self ): # pylint: disable=missing-function-docstring raise NotImplementedError @staticmethod def remove_special_chars ( string : str ) -> str : \"Ensure string is valid HTML id.\" return string . translate ( { ord ( c ): \"_\" for c in r \"!@#$%^&*()[] {} ;,<>?\\/:.|`~=_+ \" } ) def generate_html ( self , html_path = None ) -> str : \"Return `DIV` formatted with `partial_html`.\" partial = self . partial_html ( html_path = html_path ) if partial : div_id = self . remove_special_chars ( self . name ) return self . DIV . format ( id = div_id , partial = partial ) return \"\" def generate_markdown ( self , report_path : Optional [ StrPath ] = None ) -> str : # pylint: disable=missing-function-docstring \"Generate a markdown element\" raise NotImplementedError @classmethod def matches ( cls , filename , properties # pylint: disable=unused-argument ) -> bool : \"Check if the Renderer is suitable.\" return Path ( filename ) . suffix in cls . EXTENSIONS","title":"Renderer"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.generate_html","text":"Return DIV formatted with partial_html . Source code in dvc_render/base.py 54 55 56 57 58 59 60 61 62 def generate_html ( self , html_path = None ) -> str : \"Return `DIV` formatted with `partial_html`.\" partial = self . partial_html ( html_path = html_path ) if partial : div_id = self . remove_special_chars ( self . name ) return self . DIV . format ( id = div_id , partial = partial ) return \"\"","title":"generate_html()"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.generate_markdown","text":"Generate a markdown element Source code in dvc_render/base.py 64 65 66 67 68 def generate_markdown ( self , report_path : Optional [ StrPath ] = None ) -> str : # pylint: disable=missing-function-docstring \"Generate a markdown element\" raise NotImplementedError","title":"generate_markdown()"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.matches","text":"Check if the Renderer is suitable. Source code in dvc_render/base.py 70 71 72 73 74 75 @classmethod def matches ( cls , filename , properties # pylint: disable=unused-argument ) -> bool : \"Check if the Renderer is suitable.\" return Path ( filename ) . suffix in cls . EXTENSIONS","title":"matches()"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.partial_html","text":"Us this method to generate HTML content, to fill {partial} inside self.DIV. Source code in dvc_render/base.py 29 30 31 32 33 34 35 @abc . abstractmethod def partial_html ( self , ** kwargs ) -> str : \"\"\" Us this method to generate HTML content, to fill `{partial}` inside self.DIV. \"\"\" raise NotImplementedError","title":"partial_html()"},{"location":"reference/dvc_render/base/#dvc_render.base.Renderer.remove_special_chars","text":"Ensure string is valid HTML id. Source code in dvc_render/base.py 47 48 49 50 51 52 @staticmethod def remove_special_chars ( string : str ) -> str : \"Ensure string is valid HTML id.\" return string . translate ( { ord ( c ): \"_\" for c in r \"!@#$%^&*()[] {} ;,<>?\\/:.|`~=_+ \" } )","title":"remove_special_chars()"},{"location":"reference/dvc_render/exceptions/","text":"","title":"Exceptions"},{"location":"reference/dvc_render/html/","text":"HTML Source code in dvc_render/html.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class HTML : SCRIPTS_PLACEHOLDER = \"scripts\" PLOTS_PLACEHOLDER = \"plot_divs\" PLOTS_PLACEHOLDER_FORMAT_STR = f \" {{ { PLOTS_PLACEHOLDER } }} \" REFRESH_PLACEHOLDER = \"refresh_tag\" REFRESH_TAG = '<meta http-equiv=\"refresh\" content=\" {} \">' def __init__ ( self , template : Optional [ str ] = None , refresh_seconds : Optional [ int ] = None , ): template = template or PAGE_HTML if self . PLOTS_PLACEHOLDER_FORMAT_STR not in template : raise MissingPlaceholderError ( self . PLOTS_PLACEHOLDER_FORMAT_STR ) self . template = template self . elements : List [ str ] = [] self . scripts : str = \"\" self . refresh_tag = \"\" if refresh_seconds is not None : self . refresh_tag = self . REFRESH_TAG . format ( refresh_seconds ) def with_scripts ( self , scripts : str ) -> \"HTML\" : \"Extend scripts element.\" if scripts not in self . scripts : self . scripts += f \" \\n { scripts } \" return self def with_element ( self , html : str ) -> \"HTML\" : \"Adds custom html element.\" self . elements . append ( html ) return self def embed ( self ) -> str : \"Format HTML template with all elements.\" kwargs = { self . SCRIPTS_PLACEHOLDER : self . scripts , self . PLOTS_PLACEHOLDER : \" \\n \" . join ( self . elements ), self . REFRESH_PLACEHOLDER : self . refresh_tag , } for placeholder , value in kwargs . items (): self . template = self . template . replace ( \"{\" + placeholder + \"}\" , value ) return self . template embed () Format HTML template with all elements. Source code in dvc_render/html.py 67 68 69 70 71 72 73 74 75 76 77 78 def embed ( self ) -> str : \"Format HTML template with all elements.\" kwargs = { self . SCRIPTS_PLACEHOLDER : self . scripts , self . PLOTS_PLACEHOLDER : \" \\n \" . join ( self . elements ), self . REFRESH_PLACEHOLDER : self . refresh_tag , } for placeholder , value in kwargs . items (): self . template = self . template . replace ( \"{\" + placeholder + \"}\" , value ) return self . template with_element ( html ) Adds custom html element. Source code in dvc_render/html.py 62 63 64 65 def with_element ( self , html : str ) -> \"HTML\" : \"Adds custom html element.\" self . elements . append ( html ) return self with_scripts ( scripts ) Extend scripts element. Source code in dvc_render/html.py 56 57 58 59 60 def with_scripts ( self , scripts : str ) -> \"HTML\" : \"Extend scripts element.\" if scripts not in self . scripts : self . scripts += f \" \\n { scripts } \" return self render_html ( renderers , output_file , template_path = None , refresh_seconds = None ) User renderers to fill an HTML template and write to path. Source code in dvc_render/html.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def render_html ( renderers : List [ \"Renderer\" ], output_file : \"StrPath\" , template_path : Optional [ \"StrPath\" ] = None , refresh_seconds : Optional [ int ] = None , ) -> \"StrPath\" : \"User renderers to fill an HTML template and write to path.\" output_path = Path ( output_file ) output_path . parent . mkdir ( exist_ok = True ) page_html = None if template_path : with open ( template_path , encoding = \"utf-8\" ) as fobj : page_html = fobj . read () document = HTML ( page_html , refresh_seconds = refresh_seconds ) for renderer in renderers : document . with_scripts ( renderer . SCRIPTS ) document . with_element ( renderer . generate_html ( html_path = output_path )) output_path . write_text ( document . embed (), encoding = \"utf8\" ) return output_file","title":"Html"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML","text":"Source code in dvc_render/html.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class HTML : SCRIPTS_PLACEHOLDER = \"scripts\" PLOTS_PLACEHOLDER = \"plot_divs\" PLOTS_PLACEHOLDER_FORMAT_STR = f \" {{ { PLOTS_PLACEHOLDER } }} \" REFRESH_PLACEHOLDER = \"refresh_tag\" REFRESH_TAG = '<meta http-equiv=\"refresh\" content=\" {} \">' def __init__ ( self , template : Optional [ str ] = None , refresh_seconds : Optional [ int ] = None , ): template = template or PAGE_HTML if self . PLOTS_PLACEHOLDER_FORMAT_STR not in template : raise MissingPlaceholderError ( self . PLOTS_PLACEHOLDER_FORMAT_STR ) self . template = template self . elements : List [ str ] = [] self . scripts : str = \"\" self . refresh_tag = \"\" if refresh_seconds is not None : self . refresh_tag = self . REFRESH_TAG . format ( refresh_seconds ) def with_scripts ( self , scripts : str ) -> \"HTML\" : \"Extend scripts element.\" if scripts not in self . scripts : self . scripts += f \" \\n { scripts } \" return self def with_element ( self , html : str ) -> \"HTML\" : \"Adds custom html element.\" self . elements . append ( html ) return self def embed ( self ) -> str : \"Format HTML template with all elements.\" kwargs = { self . SCRIPTS_PLACEHOLDER : self . scripts , self . PLOTS_PLACEHOLDER : \" \\n \" . join ( self . elements ), self . REFRESH_PLACEHOLDER : self . refresh_tag , } for placeholder , value in kwargs . items (): self . template = self . template . replace ( \"{\" + placeholder + \"}\" , value ) return self . template","title":"HTML"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML.embed","text":"Format HTML template with all elements. Source code in dvc_render/html.py 67 68 69 70 71 72 73 74 75 76 77 78 def embed ( self ) -> str : \"Format HTML template with all elements.\" kwargs = { self . SCRIPTS_PLACEHOLDER : self . scripts , self . PLOTS_PLACEHOLDER : \" \\n \" . join ( self . elements ), self . REFRESH_PLACEHOLDER : self . refresh_tag , } for placeholder , value in kwargs . items (): self . template = self . template . replace ( \"{\" + placeholder + \"}\" , value ) return self . template","title":"embed()"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML.with_element","text":"Adds custom html element. Source code in dvc_render/html.py 62 63 64 65 def with_element ( self , html : str ) -> \"HTML\" : \"Adds custom html element.\" self . elements . append ( html ) return self","title":"with_element()"},{"location":"reference/dvc_render/html/#dvc_render.html.HTML.with_scripts","text":"Extend scripts element. Source code in dvc_render/html.py 56 57 58 59 60 def with_scripts ( self , scripts : str ) -> \"HTML\" : \"Extend scripts element.\" if scripts not in self . scripts : self . scripts += f \" \\n { scripts } \" return self","title":"with_scripts()"},{"location":"reference/dvc_render/html/#dvc_render.html.render_html","text":"User renderers to fill an HTML template and write to path. Source code in dvc_render/html.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def render_html ( renderers : List [ \"Renderer\" ], output_file : \"StrPath\" , template_path : Optional [ \"StrPath\" ] = None , refresh_seconds : Optional [ int ] = None , ) -> \"StrPath\" : \"User renderers to fill an HTML template and write to path.\" output_path = Path ( output_file ) output_path . parent . mkdir ( exist_ok = True ) page_html = None if template_path : with open ( template_path , encoding = \"utf-8\" ) as fobj : page_html = fobj . read () document = HTML ( page_html , refresh_seconds = refresh_seconds ) for renderer in renderers : document . with_scripts ( renderer . SCRIPTS ) document . with_element ( renderer . generate_html ( html_path = output_path )) output_path . write_text ( document . embed (), encoding = \"utf8\" ) return output_file","title":"render_html()"},{"location":"reference/dvc_render/image/","text":"ImageRenderer Bases: Renderer Renderer for image plots. Source code in dvc_render/image.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class ImageRenderer ( Renderer ): \"\"\"Renderer for image plots.\"\"\" TYPE = \"image\" DIV = \"\"\" <div id=\" {id} \" style=\"border:1px solid black;text-align:center; white-space: nowrap;overflow-y:hidden;\"> {partial} </div>\"\"\" TITLE_FIELD = \"rev\" SRC_FIELD = \"src\" SCRIPTS = \"\" EXTENSIONS = { \".jpg\" , \".jpeg\" , \".gif\" , \".png\" } def partial_html ( self , html_path = None , ** kwargs ) -> str : div_content = [] for datapoint in self . datapoints : src = datapoint [ self . SRC_FIELD ] if ( not src . startswith ( \"data:image;base64\" ) and os . path . isabs ( src ) and html_path ): src = os . path . relpath ( src , os . path . dirname ( html_path )) div_content . append ( f \"\"\" <div style=\"border:1px dotted black;margin:2px;display: inline-block; overflow:hidden;margin-left:8px;\"> <p> { datapoint [ self . TITLE_FIELD ] } </p> <img src=\" { src } \"> </div> \"\"\" ) if div_content : div_content . insert ( 0 , f \"<p> { self . name } </p>\" ) return \" \\n \" . join ( div_content ) return \"\" def generate_markdown ( self , report_path = None ) -> str : content = [] for datapoint in self . datapoints : src = datapoint [ self . SRC_FIELD ] if src . startswith ( \"data:image;base64\" ): raise ValueError ( \"`generate_markdown` doesn't support base64\" ) content . append ( f \" \\n ![ { datapoint [ self . TITLE_FIELD ] } ]( { src } )\" ) if content : return \" \\n \" . join ( content ) return \"\"","title":"Image"},{"location":"reference/dvc_render/image/#dvc_render.image.ImageRenderer","text":"Bases: Renderer Renderer for image plots. Source code in dvc_render/image.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class ImageRenderer ( Renderer ): \"\"\"Renderer for image plots.\"\"\" TYPE = \"image\" DIV = \"\"\" <div id=\" {id} \" style=\"border:1px solid black;text-align:center; white-space: nowrap;overflow-y:hidden;\"> {partial} </div>\"\"\" TITLE_FIELD = \"rev\" SRC_FIELD = \"src\" SCRIPTS = \"\" EXTENSIONS = { \".jpg\" , \".jpeg\" , \".gif\" , \".png\" } def partial_html ( self , html_path = None , ** kwargs ) -> str : div_content = [] for datapoint in self . datapoints : src = datapoint [ self . SRC_FIELD ] if ( not src . startswith ( \"data:image;base64\" ) and os . path . isabs ( src ) and html_path ): src = os . path . relpath ( src , os . path . dirname ( html_path )) div_content . append ( f \"\"\" <div style=\"border:1px dotted black;margin:2px;display: inline-block; overflow:hidden;margin-left:8px;\"> <p> { datapoint [ self . TITLE_FIELD ] } </p> <img src=\" { src } \"> </div> \"\"\" ) if div_content : div_content . insert ( 0 , f \"<p> { self . name } </p>\" ) return \" \\n \" . join ( div_content ) return \"\" def generate_markdown ( self , report_path = None ) -> str : content = [] for datapoint in self . datapoints : src = datapoint [ self . SRC_FIELD ] if src . startswith ( \"data:image;base64\" ): raise ValueError ( \"`generate_markdown` doesn't support base64\" ) content . append ( f \" \\n ![ { datapoint [ self . TITLE_FIELD ] } ]( { src } )\" ) if content : return \" \\n \" . join ( content ) return \"\"","title":"ImageRenderer"},{"location":"reference/dvc_render/markdown/","text":"Markdown Source code in dvc_render/markdown.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Markdown : RENDERERS_PLACEHOLDER = \"renderers\" RENDERERS_PLACEHOLDER_FORMAT_STR = f \" {{ { RENDERERS_PLACEHOLDER } }} \" def __init__ ( self , template : Optional [ str ] = None , ): template = template or PAGE_MARKDOWN if self . RENDERERS_PLACEHOLDER_FORMAT_STR not in template : raise MissingPlaceholderError ( self . RENDERERS_PLACEHOLDER_FORMAT_STR , \"Markdown\" ) self . template = template self . elements : List [ str ] = [] def with_element ( self , md : str ) -> \"Markdown\" : \"Adds custom markdown element.\" self . elements . append ( md ) return self def embed ( self ) -> str : \"Format Markdown template with all elements.\" kwargs = { self . RENDERERS_PLACEHOLDER : \" \\n \" . join ( self . elements ), } for placeholder , value in kwargs . items (): self . template = self . template . replace ( \"{\" + placeholder + \"}\" , value ) return self . template embed () Format Markdown template with all elements. Source code in dvc_render/markdown.py 37 38 39 40 41 42 43 44 45 46 def embed ( self ) -> str : \"Format Markdown template with all elements.\" kwargs = { self . RENDERERS_PLACEHOLDER : \" \\n \" . join ( self . elements ), } for placeholder , value in kwargs . items (): self . template = self . template . replace ( \"{\" + placeholder + \"}\" , value ) return self . template with_element ( md ) Adds custom markdown element. Source code in dvc_render/markdown.py 32 33 34 35 def with_element ( self , md : str ) -> \"Markdown\" : \"Adds custom markdown element.\" self . elements . append ( md ) return self render_markdown ( renderers , output_file , template_path = None ) User renderers to fill an Markdown template and write to path. Source code in dvc_render/markdown.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def render_markdown ( renderers : List [ \"Renderer\" ], output_file : \"StrPath\" , template_path : Optional [ \"StrPath\" ] = None , ) -> \"StrPath\" : \"User renderers to fill an Markdown template and write to path.\" output_path = Path ( output_file ) output_path . parent . mkdir ( exist_ok = True ) page = None if template_path : with open ( template_path , encoding = \"utf-8\" ) as fobj : page = fobj . read () document = Markdown ( page ) for renderer in renderers : document . with_element ( renderer . generate_markdown ( report_path = output_path ) ) output_path . write_text ( document . embed (), encoding = \"utf8\" ) return output_file","title":"Markdown"},{"location":"reference/dvc_render/markdown/#dvc_render.markdown.Markdown","text":"Source code in dvc_render/markdown.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Markdown : RENDERERS_PLACEHOLDER = \"renderers\" RENDERERS_PLACEHOLDER_FORMAT_STR = f \" {{ { RENDERERS_PLACEHOLDER } }} \" def __init__ ( self , template : Optional [ str ] = None , ): template = template or PAGE_MARKDOWN if self . RENDERERS_PLACEHOLDER_FORMAT_STR not in template : raise MissingPlaceholderError ( self . RENDERERS_PLACEHOLDER_FORMAT_STR , \"Markdown\" ) self . template = template self . elements : List [ str ] = [] def with_element ( self , md : str ) -> \"Markdown\" : \"Adds custom markdown element.\" self . elements . append ( md ) return self def embed ( self ) -> str : \"Format Markdown template with all elements.\" kwargs = { self . RENDERERS_PLACEHOLDER : \" \\n \" . join ( self . elements ), } for placeholder , value in kwargs . items (): self . template = self . template . replace ( \"{\" + placeholder + \"}\" , value ) return self . template","title":"Markdown"},{"location":"reference/dvc_render/markdown/#dvc_render.markdown.Markdown.embed","text":"Format Markdown template with all elements. Source code in dvc_render/markdown.py 37 38 39 40 41 42 43 44 45 46 def embed ( self ) -> str : \"Format Markdown template with all elements.\" kwargs = { self . RENDERERS_PLACEHOLDER : \" \\n \" . join ( self . elements ), } for placeholder , value in kwargs . items (): self . template = self . template . replace ( \"{\" + placeholder + \"}\" , value ) return self . template","title":"embed()"},{"location":"reference/dvc_render/markdown/#dvc_render.markdown.Markdown.with_element","text":"Adds custom markdown element. Source code in dvc_render/markdown.py 32 33 34 35 def with_element ( self , md : str ) -> \"Markdown\" : \"Adds custom markdown element.\" self . elements . append ( md ) return self","title":"with_element()"},{"location":"reference/dvc_render/markdown/#dvc_render.markdown.render_markdown","text":"User renderers to fill an Markdown template and write to path. Source code in dvc_render/markdown.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def render_markdown ( renderers : List [ \"Renderer\" ], output_file : \"StrPath\" , template_path : Optional [ \"StrPath\" ] = None , ) -> \"StrPath\" : \"User renderers to fill an Markdown template and write to path.\" output_path = Path ( output_file ) output_path . parent . mkdir ( exist_ok = True ) page = None if template_path : with open ( template_path , encoding = \"utf-8\" ) as fobj : page = fobj . read () document = Markdown ( page ) for renderer in renderers : document . with_element ( renderer . generate_markdown ( report_path = output_path ) ) output_path . write_text ( document . embed (), encoding = \"utf8\" ) return output_file","title":"render_markdown()"},{"location":"reference/dvc_render/plotly/","text":"ParallelCoordinatesRenderer Bases: Renderer Renderer for Parallel Coordinates plot. Using Plotly. Source code in dvc_render/plotly.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class ParallelCoordinatesRenderer ( Renderer ): \"\"\" Renderer for Parallel Coordinates plot. Using Plotly. \"\"\" TYPE = \"plotly\" DIV = \"\"\" <div id = \" {id} \"> <script type = \"text/javascript\"> var plotly_data = {partial} ; Plotly.newPlot(\" {id} \", plotly_data.data, plotly_data.layout); </script> </div> \"\"\" EXTENSIONS = { \".json\" } SCRIPTS = \"\"\" <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script> \"\"\" # pylint: disable=W0231 def __init__ ( self , datapoints , name = \"pcp\" , color_by : Optional [ str ] = None , fill_value : str = \"\" , ): self . datapoints = datapoints self . color_by = color_by self . name = name self . fill_value = fill_value def partial_html ( self , ** kwargs ) -> str : return json . dumps ( self . _get_plotly_data ()) def _get_plotly_data ( self ): tabular_dict = list_dict_to_dict_list ( self . datapoints ) trace : Dict [ str , Any ] = { \"type\" : \"parcoords\" , \"dimensions\" : []} for label , values in tabular_dict . items (): values = list ( map ( str , values )) is_categorical = False try : float_values = [ float ( x ) if x != self . fill_value else None for x in values ] except ValueError : is_categorical = True if is_categorical : non_missing = [ x for x in values if x != self . fill_value ] unique_values = sorted ( set ( non_missing )) unique_values . append ( self . fill_value ) dummy_values = [ unique_values . index ( x ) for x in values ] values = [ x if x != self . fill_value else \"Missing\" for x in values ] trace [ \"dimensions\" ] . append ( { \"label\" : label , \"values\" : dummy_values , \"tickvals\" : dummy_values , \"ticktext\" : values , } ) else : trace [ \"dimensions\" ] . append ( { \"label\" : label , \"values\" : float_values } ) if label == self . color_by : trace [ \"line\" ] = { \"color\" : dummy_values if is_categorical else float_values , \"showscale\" : True , \"colorbar\" : { \"title\" : self . color_by }, } if is_categorical : trace [ \"line\" ][ \"colorbar\" ][ \"tickmode\" ] = \"array\" trace [ \"line\" ][ \"colorbar\" ][ \"tickvals\" ] = dummy_values trace [ \"line\" ][ \"colorbar\" ][ \"ticktext\" ] = values return { \"data\" : [ trace ], \"layout\" : {}}","title":"Plotly"},{"location":"reference/dvc_render/plotly/#dvc_render.plotly.ParallelCoordinatesRenderer","text":"Bases: Renderer Renderer for Parallel Coordinates plot. Using Plotly. Source code in dvc_render/plotly.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class ParallelCoordinatesRenderer ( Renderer ): \"\"\" Renderer for Parallel Coordinates plot. Using Plotly. \"\"\" TYPE = \"plotly\" DIV = \"\"\" <div id = \" {id} \"> <script type = \"text/javascript\"> var plotly_data = {partial} ; Plotly.newPlot(\" {id} \", plotly_data.data, plotly_data.layout); </script> </div> \"\"\" EXTENSIONS = { \".json\" } SCRIPTS = \"\"\" <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script> \"\"\" # pylint: disable=W0231 def __init__ ( self , datapoints , name = \"pcp\" , color_by : Optional [ str ] = None , fill_value : str = \"\" , ): self . datapoints = datapoints self . color_by = color_by self . name = name self . fill_value = fill_value def partial_html ( self , ** kwargs ) -> str : return json . dumps ( self . _get_plotly_data ()) def _get_plotly_data ( self ): tabular_dict = list_dict_to_dict_list ( self . datapoints ) trace : Dict [ str , Any ] = { \"type\" : \"parcoords\" , \"dimensions\" : []} for label , values in tabular_dict . items (): values = list ( map ( str , values )) is_categorical = False try : float_values = [ float ( x ) if x != self . fill_value else None for x in values ] except ValueError : is_categorical = True if is_categorical : non_missing = [ x for x in values if x != self . fill_value ] unique_values = sorted ( set ( non_missing )) unique_values . append ( self . fill_value ) dummy_values = [ unique_values . index ( x ) for x in values ] values = [ x if x != self . fill_value else \"Missing\" for x in values ] trace [ \"dimensions\" ] . append ( { \"label\" : label , \"values\" : dummy_values , \"tickvals\" : dummy_values , \"ticktext\" : values , } ) else : trace [ \"dimensions\" ] . append ( { \"label\" : label , \"values\" : float_values } ) if label == self . color_by : trace [ \"line\" ] = { \"color\" : dummy_values if is_categorical else float_values , \"showscale\" : True , \"colorbar\" : { \"title\" : self . color_by }, } if is_categorical : trace [ \"line\" ][ \"colorbar\" ][ \"tickmode\" ] = \"array\" trace [ \"line\" ][ \"colorbar\" ][ \"tickvals\" ] = dummy_values trace [ \"line\" ][ \"colorbar\" ][ \"ticktext\" ] = values return { \"data\" : [ trace ], \"layout\" : {}}","title":"ParallelCoordinatesRenderer"},{"location":"reference/dvc_render/table/","text":"TableRenderer Bases: Renderer Renderer for tables. Source code in dvc_render/table.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class TableRenderer ( Renderer ): \"\"\"Renderer for tables.\"\"\" TYPE = \"table\" DIV = \"\"\" <div id=\" {id} \" style=\"text-align: center; padding: 10x\"> <p> {id} </p> <div style=\"display: flex;justify-content: center;\"> {partial} </div> </div>\"\"\" SCRIPTS = \"\" EXTENSIONS = { \".yml\" , \".yaml\" , \".json\" } @classmethod def to_tabulate ( cls , datapoints , tablefmt ): \"\"\"Convert datapoints to tabulate format\"\"\" if tabulate is None : raise ImportError ( f \" { cls . __name__ } requires `tabulate`.\" ) data = list_dict_to_dict_list ( datapoints ) return tabulate ( data , headers = \"keys\" , tablefmt = tablefmt ) def partial_html ( self , ** kwargs ) -> str : return self . to_tabulate ( self . datapoints , tablefmt = \"html\" ) def generate_markdown ( self , report_path = None ) -> str : table = self . to_tabulate ( self . datapoints , tablefmt = \"github\" ) return f \" \\n { self . name } \\n\\n { table } \" to_tabulate ( datapoints , tablefmt ) classmethod Convert datapoints to tabulate format Source code in dvc_render/table.py 26 27 28 29 30 31 32 @classmethod def to_tabulate ( cls , datapoints , tablefmt ): \"\"\"Convert datapoints to tabulate format\"\"\" if tabulate is None : raise ImportError ( f \" { cls . __name__ } requires `tabulate`.\" ) data = list_dict_to_dict_list ( datapoints ) return tabulate ( data , headers = \"keys\" , tablefmt = tablefmt )","title":"Table"},{"location":"reference/dvc_render/table/#dvc_render.table.TableRenderer","text":"Bases: Renderer Renderer for tables. Source code in dvc_render/table.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class TableRenderer ( Renderer ): \"\"\"Renderer for tables.\"\"\" TYPE = \"table\" DIV = \"\"\" <div id=\" {id} \" style=\"text-align: center; padding: 10x\"> <p> {id} </p> <div style=\"display: flex;justify-content: center;\"> {partial} </div> </div>\"\"\" SCRIPTS = \"\" EXTENSIONS = { \".yml\" , \".yaml\" , \".json\" } @classmethod def to_tabulate ( cls , datapoints , tablefmt ): \"\"\"Convert datapoints to tabulate format\"\"\" if tabulate is None : raise ImportError ( f \" { cls . __name__ } requires `tabulate`.\" ) data = list_dict_to_dict_list ( datapoints ) return tabulate ( data , headers = \"keys\" , tablefmt = tablefmt ) def partial_html ( self , ** kwargs ) -> str : return self . to_tabulate ( self . datapoints , tablefmt = \"html\" ) def generate_markdown ( self , report_path = None ) -> str : table = self . to_tabulate ( self . datapoints , tablefmt = \"github\" ) return f \" \\n { self . name } \\n\\n { table } \"","title":"TableRenderer"},{"location":"reference/dvc_render/table/#dvc_render.table.TableRenderer.to_tabulate","text":"Convert datapoints to tabulate format Source code in dvc_render/table.py 26 27 28 29 30 31 32 @classmethod def to_tabulate ( cls , datapoints , tablefmt ): \"\"\"Convert datapoints to tabulate format\"\"\" if tabulate is None : raise ImportError ( f \" { cls . __name__ } requires `tabulate`.\" ) data = list_dict_to_dict_list ( datapoints ) return tabulate ( data , headers = \"keys\" , tablefmt = tablefmt )","title":"to_tabulate()"},{"location":"reference/dvc_render/utils/","text":"list_dict_to_dict_list ( list_dict ) Convert from list of dictionaries to dictionary of lists. Source code in dvc_render/utils.py 1 2 3 4 5 def list_dict_to_dict_list ( list_dict ): \"\"\"Convert from list of dictionaries to dictionary of lists.\"\"\" if not list_dict : return {} return { k : [ x [ k ] for x in list_dict ] for k in list_dict [ 0 ]}","title":"Utils"},{"location":"reference/dvc_render/utils/#dvc_render.utils.list_dict_to_dict_list","text":"Convert from list of dictionaries to dictionary of lists. Source code in dvc_render/utils.py 1 2 3 4 5 def list_dict_to_dict_list ( list_dict ): \"\"\"Convert from list of dictionaries to dictionary of lists.\"\"\" if not list_dict : return {} return { k : [ x [ k ] for x in list_dict ] for k in list_dict [ 0 ]}","title":"list_dict_to_dict_list()"},{"location":"reference/dvc_render/vega/","text":"VegaRenderer Bases: Renderer Renderer for vega plots. Source code in dvc_render/vega.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 class VegaRenderer ( Renderer ): \"\"\"Renderer for vega plots.\"\"\" TYPE = \"vega\" DIV = \"\"\" <div id = \" {id} \"> <script type = \"text/javascript\"> var spec = {partial} ; vegaEmbed('# {id} ', spec); </script> </div> \"\"\" SCRIPTS = \"\"\" <script src=\"https://cdn.jsdelivr.net/npm/vega@5.20.2\"></script> <script src=\"https://cdn.jsdelivr.net/npm/vega-lite@5.2.0\"></script> <script src=\"https://cdn.jsdelivr.net/npm/vega-embed@6.18.2\"></script> \"\"\" EXTENSIONS = { \".yml\" , \".yaml\" , \".json\" , \".csv\" , \".tsv\" } def __init__ ( self , datapoints : List , name : str , ** properties ): super () . __init__ ( datapoints , name , ** properties ) self . template = get_template ( self . properties . get ( \"template\" , None ), self . properties . get ( \"template_dir\" , None ), ) def get_filled_template ( self , skip_anchors : Optional [ List [ str ]] = None , strict : bool = True ) -> str : \"\"\"Returns a functional vega specification\"\"\" if not self . datapoints : return \"\" if skip_anchors is None : skip_anchors = [] content = deepcopy ( self . template . content ) if strict : if self . properties . get ( \"x\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"x\" ) ) if self . properties . get ( \"y\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"y\" ) ) self . properties . setdefault ( \"title\" , \"\" ) self . properties . setdefault ( \"x_label\" , self . properties . get ( \"x\" )) self . properties . setdefault ( \"y_label\" , self . properties . get ( \"y\" )) self . properties . setdefault ( \"data\" , self . datapoints ) names = [ \"title\" , \"x\" , \"y\" , \"x_label\" , \"y_label\" , \"data\" ] for name in names : if name in skip_anchors : continue value = self . properties . get ( name ) if value is None : continue if name == \"data\" : if self . template . anchor_str ( name ) not in self . template . content : anchor = self . template . anchor ( name ) raise BadTemplateError ( f \"Template ' { self . template . name } ' \" f \"is not using ' { anchor } ' anchor\" ) elif name in { \"x\" , \"y\" }: value = self . template . escape_special_characters ( value ) content = self . template . fill_anchor ( content , name , value ) return content def partial_html ( self , ** kwargs ) -> str : return self . get_filled_template () def generate_markdown ( self , report_path = None ) -> str : if not isinstance ( self . template , LinearTemplate ): raise ValueError ( \"`generate_markdown` can only be used with `LinearTemplate`\" ) try : from matplotlib import pyplot as plt except ImportError as e : raise ImportError ( \"matplotlib is required for `generate_markdown`\" ) from e data = list_dict_to_dict_list ( self . datapoints ) if data : report_folder = Path ( report_path ) . parent output_file = report_folder / self . name output_file = output_file . with_suffix ( \".png\" ) output_file . parent . mkdir ( exist_ok = True , parents = True ) x = self . properties . get ( \"x\" ) y = self . properties . get ( \"y\" ) data [ x ] = list ( map ( float , data [ x ])) data [ y ] = list ( map ( float , data [ y ])) plt . title ( self . properties . get ( \"title\" , output_file . stem )) plt . xlabel ( self . properties . get ( \"x_label\" , x )) plt . ylabel ( self . properties . get ( \"y_label\" , y )) plt . plot ( x , y , data = data ) plt . tight_layout () plt . savefig ( output_file ) plt . close () return ( f \" \\n ![ { self . name } ]( { output_file . relative_to ( report_folder ) } )\" ) return \"\" get_filled_template ( skip_anchors = None , strict = True ) Returns a functional vega specification Source code in dvc_render/vega.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def get_filled_template ( self , skip_anchors : Optional [ List [ str ]] = None , strict : bool = True ) -> str : \"\"\"Returns a functional vega specification\"\"\" if not self . datapoints : return \"\" if skip_anchors is None : skip_anchors = [] content = deepcopy ( self . template . content ) if strict : if self . properties . get ( \"x\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"x\" ) ) if self . properties . get ( \"y\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"y\" ) ) self . properties . setdefault ( \"title\" , \"\" ) self . properties . setdefault ( \"x_label\" , self . properties . get ( \"x\" )) self . properties . setdefault ( \"y_label\" , self . properties . get ( \"y\" )) self . properties . setdefault ( \"data\" , self . datapoints ) names = [ \"title\" , \"x\" , \"y\" , \"x_label\" , \"y_label\" , \"data\" ] for name in names : if name in skip_anchors : continue value = self . properties . get ( name ) if value is None : continue if name == \"data\" : if self . template . anchor_str ( name ) not in self . template . content : anchor = self . template . anchor ( name ) raise BadTemplateError ( f \"Template ' { self . template . name } ' \" f \"is not using ' { anchor } ' anchor\" ) elif name in { \"x\" , \"y\" }: value = self . template . escape_special_characters ( value ) content = self . template . fill_anchor ( content , name , value ) return content","title":"Vega"},{"location":"reference/dvc_render/vega/#dvc_render.vega.VegaRenderer","text":"Bases: Renderer Renderer for vega plots. Source code in dvc_render/vega.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 class VegaRenderer ( Renderer ): \"\"\"Renderer for vega plots.\"\"\" TYPE = \"vega\" DIV = \"\"\" <div id = \" {id} \"> <script type = \"text/javascript\"> var spec = {partial} ; vegaEmbed('# {id} ', spec); </script> </div> \"\"\" SCRIPTS = \"\"\" <script src=\"https://cdn.jsdelivr.net/npm/vega@5.20.2\"></script> <script src=\"https://cdn.jsdelivr.net/npm/vega-lite@5.2.0\"></script> <script src=\"https://cdn.jsdelivr.net/npm/vega-embed@6.18.2\"></script> \"\"\" EXTENSIONS = { \".yml\" , \".yaml\" , \".json\" , \".csv\" , \".tsv\" } def __init__ ( self , datapoints : List , name : str , ** properties ): super () . __init__ ( datapoints , name , ** properties ) self . template = get_template ( self . properties . get ( \"template\" , None ), self . properties . get ( \"template_dir\" , None ), ) def get_filled_template ( self , skip_anchors : Optional [ List [ str ]] = None , strict : bool = True ) -> str : \"\"\"Returns a functional vega specification\"\"\" if not self . datapoints : return \"\" if skip_anchors is None : skip_anchors = [] content = deepcopy ( self . template . content ) if strict : if self . properties . get ( \"x\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"x\" ) ) if self . properties . get ( \"y\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"y\" ) ) self . properties . setdefault ( \"title\" , \"\" ) self . properties . setdefault ( \"x_label\" , self . properties . get ( \"x\" )) self . properties . setdefault ( \"y_label\" , self . properties . get ( \"y\" )) self . properties . setdefault ( \"data\" , self . datapoints ) names = [ \"title\" , \"x\" , \"y\" , \"x_label\" , \"y_label\" , \"data\" ] for name in names : if name in skip_anchors : continue value = self . properties . get ( name ) if value is None : continue if name == \"data\" : if self . template . anchor_str ( name ) not in self . template . content : anchor = self . template . anchor ( name ) raise BadTemplateError ( f \"Template ' { self . template . name } ' \" f \"is not using ' { anchor } ' anchor\" ) elif name in { \"x\" , \"y\" }: value = self . template . escape_special_characters ( value ) content = self . template . fill_anchor ( content , name , value ) return content def partial_html ( self , ** kwargs ) -> str : return self . get_filled_template () def generate_markdown ( self , report_path = None ) -> str : if not isinstance ( self . template , LinearTemplate ): raise ValueError ( \"`generate_markdown` can only be used with `LinearTemplate`\" ) try : from matplotlib import pyplot as plt except ImportError as e : raise ImportError ( \"matplotlib is required for `generate_markdown`\" ) from e data = list_dict_to_dict_list ( self . datapoints ) if data : report_folder = Path ( report_path ) . parent output_file = report_folder / self . name output_file = output_file . with_suffix ( \".png\" ) output_file . parent . mkdir ( exist_ok = True , parents = True ) x = self . properties . get ( \"x\" ) y = self . properties . get ( \"y\" ) data [ x ] = list ( map ( float , data [ x ])) data [ y ] = list ( map ( float , data [ y ])) plt . title ( self . properties . get ( \"title\" , output_file . stem )) plt . xlabel ( self . properties . get ( \"x_label\" , x )) plt . ylabel ( self . properties . get ( \"y_label\" , y )) plt . plot ( x , y , data = data ) plt . tight_layout () plt . savefig ( output_file ) plt . close () return ( f \" \\n ![ { self . name } ]( { output_file . relative_to ( report_folder ) } )\" ) return \"\"","title":"VegaRenderer"},{"location":"reference/dvc_render/vega/#dvc_render.vega.VegaRenderer.get_filled_template","text":"Returns a functional vega specification Source code in dvc_render/vega.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def get_filled_template ( self , skip_anchors : Optional [ List [ str ]] = None , strict : bool = True ) -> str : \"\"\"Returns a functional vega specification\"\"\" if not self . datapoints : return \"\" if skip_anchors is None : skip_anchors = [] content = deepcopy ( self . template . content ) if strict : if self . properties . get ( \"x\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"x\" ) ) if self . properties . get ( \"y\" ): self . template . check_field_exists ( self . datapoints , self . properties . get ( \"y\" ) ) self . properties . setdefault ( \"title\" , \"\" ) self . properties . setdefault ( \"x_label\" , self . properties . get ( \"x\" )) self . properties . setdefault ( \"y_label\" , self . properties . get ( \"y\" )) self . properties . setdefault ( \"data\" , self . datapoints ) names = [ \"title\" , \"x\" , \"y\" , \"x_label\" , \"y_label\" , \"data\" ] for name in names : if name in skip_anchors : continue value = self . properties . get ( name ) if value is None : continue if name == \"data\" : if self . template . anchor_str ( name ) not in self . template . content : anchor = self . template . anchor ( name ) raise BadTemplateError ( f \"Template ' { self . template . name } ' \" f \"is not using ' { anchor } ' anchor\" ) elif name in { \"x\" , \"y\" }: value = self . template . escape_special_characters ( value ) content = self . template . fill_anchor ( content , name , value ) return content","title":"get_filled_template()"},{"location":"reference/dvc_render/vega_templates/","text":"Template Source code in dvc_render/vega_templates.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class Template : INDENT = 4 SEPARATORS = ( \",\" , \": \" ) EXTENSION = \".json\" ANCHOR = \"<DVC_METRIC_ {} >\" DEFAULT_CONTENT : Optional [ Dict [ str , Any ]] = None DEFAULT_NAME : Optional [ str ] = None def __init__ ( self , content = None , name = None ): if content : self . content = content else : self . content = ( json . dumps ( self . DEFAULT_CONTENT , indent = self . INDENT , separators = self . SEPARATORS , ) + \" \\n \" ) self . name = name or self . DEFAULT_NAME assert self . content and self . name self . filename = Path ( self . name ) . with_suffix ( self . EXTENSION ) @classmethod def anchor ( cls , name ): \"Get ANCHOR formatted with name.\" return cls . ANCHOR . format ( name . upper ()) def has_anchor ( self , name ) -> bool : \"Check if ANCHOR formatted with name is in content.\" return self . anchor_str ( name ) in self . content @classmethod def fill_anchor ( cls , content , name , value ) -> str : \"Replace anchor `name` with `value` in content.\" value_str = json . dumps ( value , indent = cls . INDENT , separators = cls . SEPARATORS , sort_keys = True ) return content . replace ( cls . anchor_str ( name ), value_str ) @classmethod def escape_special_characters ( cls , value : str ) -> str : \"Escape special characters in `value`\" for character in ( \".\" , \"[\" , \"]\" ): value = value . replace ( character , \" \\\\ \" + character ) return value @classmethod def anchor_str ( cls , name ) -> str : \"Get string wrapping ANCHOR formatted with name.\" return f '\" { cls . anchor ( name ) } \"' @staticmethod def check_field_exists ( data , field ): \"Raise NoFieldInDataError if `field` not in `data`.\" if not any ( field in row for row in data ): raise NoFieldInDataError ( field ) anchor ( name ) classmethod Get ANCHOR formatted with name. Source code in dvc_render/vega_templates.py 58 59 60 61 @classmethod def anchor ( cls , name ): \"Get ANCHOR formatted with name.\" return cls . ANCHOR . format ( name . upper ()) anchor_str ( name ) classmethod Get string wrapping ANCHOR formatted with name. Source code in dvc_render/vega_templates.py 82 83 84 85 @classmethod def anchor_str ( cls , name ) -> str : \"Get string wrapping ANCHOR formatted with name.\" return f '\" { cls . anchor ( name ) } \"' check_field_exists ( data , field ) staticmethod Raise NoFieldInDataError if field not in data . Source code in dvc_render/vega_templates.py 87 88 89 90 91 @staticmethod def check_field_exists ( data , field ): \"Raise NoFieldInDataError if `field` not in `data`.\" if not any ( field in row for row in data ): raise NoFieldInDataError ( field ) escape_special_characters ( value ) classmethod Escape special characters in value Source code in dvc_render/vega_templates.py 75 76 77 78 79 80 @classmethod def escape_special_characters ( cls , value : str ) -> str : \"Escape special characters in `value`\" for character in ( \".\" , \"[\" , \"]\" ): value = value . replace ( character , \" \\\\ \" + character ) return value fill_anchor ( content , name , value ) classmethod Replace anchor name with value in content. Source code in dvc_render/vega_templates.py 67 68 69 70 71 72 73 @classmethod def fill_anchor ( cls , content , name , value ) -> str : \"Replace anchor `name` with `value` in content.\" value_str = json . dumps ( value , indent = cls . INDENT , separators = cls . SEPARATORS , sort_keys = True ) return content . replace ( cls . anchor_str ( name ), value_str ) has_anchor ( name ) Check if ANCHOR formatted with name is in content. Source code in dvc_render/vega_templates.py 63 64 65 def has_anchor ( self , name ) -> bool : \"Check if ANCHOR formatted with name is in content.\" return self . anchor_str ( name ) in self . content dump_templates ( output , targets = None ) Write TEMPLATES in .json format to output . Source code in dvc_render/vega_templates.py 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 def dump_templates ( output : \"StrPath\" , targets : Optional [ List ] = None ) -> None : \"Write TEMPLATES in `.json` format to `output`.\" output = Path ( output ) output . mkdir ( exist_ok = True ) if targets : templates = [ template for template in TEMPLATES if template . DEFAULT_NAME in targets ] else : templates = TEMPLATES for template_cls in templates : template = template_cls () path = output / template . filename if path . exists (): content = path . read_text ( encoding = \"utf-8\" ) if content != template . content : raise TemplateContentDoesNotMatch ( template . DEFAULT_NAME or \"\" , path ) else : path . write_text ( template . content , encoding = \"utf-8\" ) get_template ( template = None , template_dir = None ) Return template instance based on given template arg. If template is already an instance, return it. If template is None, return default linear template. If template is a path, will try to find it as absolute path or inside template_dir. If template matches one of the DEFAULT_NAMEs in TEMPLATES, return an instance of the one matching. Source code in dvc_render/vega_templates.py 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 def get_template ( template : Union [ Optional [ str ], Template ] = None , template_dir : Optional [ str ] = None , ) -> Template : \"\"\"Return template instance based on given template arg. If template is already an instance, return it. If template is None, return default `linear` template. If template is a path, will try to find it as absolute path or inside template_dir. If template matches one of the DEFAULT_NAMEs in TEMPLATES, return an instance of the one matching. \"\"\" if isinstance ( template , Template ): return template if template is None : template = \"linear\" template_path = _find_template ( template , template_dir ) if template_path : with open ( template_path , \"r\" , encoding = \"utf-8\" ) as f : content = f . read () return Template ( content , name = template ) for template_cls in TEMPLATES : if template_cls . DEFAULT_NAME == template : return template_cls () raise TemplateNotFoundError ( template )","title":"Vega templates"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template","text":"Source code in dvc_render/vega_templates.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class Template : INDENT = 4 SEPARATORS = ( \",\" , \": \" ) EXTENSION = \".json\" ANCHOR = \"<DVC_METRIC_ {} >\" DEFAULT_CONTENT : Optional [ Dict [ str , Any ]] = None DEFAULT_NAME : Optional [ str ] = None def __init__ ( self , content = None , name = None ): if content : self . content = content else : self . content = ( json . dumps ( self . DEFAULT_CONTENT , indent = self . INDENT , separators = self . SEPARATORS , ) + \" \\n \" ) self . name = name or self . DEFAULT_NAME assert self . content and self . name self . filename = Path ( self . name ) . with_suffix ( self . EXTENSION ) @classmethod def anchor ( cls , name ): \"Get ANCHOR formatted with name.\" return cls . ANCHOR . format ( name . upper ()) def has_anchor ( self , name ) -> bool : \"Check if ANCHOR formatted with name is in content.\" return self . anchor_str ( name ) in self . content @classmethod def fill_anchor ( cls , content , name , value ) -> str : \"Replace anchor `name` with `value` in content.\" value_str = json . dumps ( value , indent = cls . INDENT , separators = cls . SEPARATORS , sort_keys = True ) return content . replace ( cls . anchor_str ( name ), value_str ) @classmethod def escape_special_characters ( cls , value : str ) -> str : \"Escape special characters in `value`\" for character in ( \".\" , \"[\" , \"]\" ): value = value . replace ( character , \" \\\\ \" + character ) return value @classmethod def anchor_str ( cls , name ) -> str : \"Get string wrapping ANCHOR formatted with name.\" return f '\" { cls . anchor ( name ) } \"' @staticmethod def check_field_exists ( data , field ): \"Raise NoFieldInDataError if `field` not in `data`.\" if not any ( field in row for row in data ): raise NoFieldInDataError ( field )","title":"Template"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.anchor","text":"Get ANCHOR formatted with name. Source code in dvc_render/vega_templates.py 58 59 60 61 @classmethod def anchor ( cls , name ): \"Get ANCHOR formatted with name.\" return cls . ANCHOR . format ( name . upper ())","title":"anchor()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.anchor_str","text":"Get string wrapping ANCHOR formatted with name. Source code in dvc_render/vega_templates.py 82 83 84 85 @classmethod def anchor_str ( cls , name ) -> str : \"Get string wrapping ANCHOR formatted with name.\" return f '\" { cls . anchor ( name ) } \"'","title":"anchor_str()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.check_field_exists","text":"Raise NoFieldInDataError if field not in data . Source code in dvc_render/vega_templates.py 87 88 89 90 91 @staticmethod def check_field_exists ( data , field ): \"Raise NoFieldInDataError if `field` not in `data`.\" if not any ( field in row for row in data ): raise NoFieldInDataError ( field )","title":"check_field_exists()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.escape_special_characters","text":"Escape special characters in value Source code in dvc_render/vega_templates.py 75 76 77 78 79 80 @classmethod def escape_special_characters ( cls , value : str ) -> str : \"Escape special characters in `value`\" for character in ( \".\" , \"[\" , \"]\" ): value = value . replace ( character , \" \\\\ \" + character ) return value","title":"escape_special_characters()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.fill_anchor","text":"Replace anchor name with value in content. Source code in dvc_render/vega_templates.py 67 68 69 70 71 72 73 @classmethod def fill_anchor ( cls , content , name , value ) -> str : \"Replace anchor `name` with `value` in content.\" value_str = json . dumps ( value , indent = cls . INDENT , separators = cls . SEPARATORS , sort_keys = True ) return content . replace ( cls . anchor_str ( name ), value_str )","title":"fill_anchor()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.Template.has_anchor","text":"Check if ANCHOR formatted with name is in content. Source code in dvc_render/vega_templates.py 63 64 65 def has_anchor ( self , name ) -> bool : \"Check if ANCHOR formatted with name is in content.\" return self . anchor_str ( name ) in self . content","title":"has_anchor()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.dump_templates","text":"Write TEMPLATES in .json format to output . Source code in dvc_render/vega_templates.py 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 def dump_templates ( output : \"StrPath\" , targets : Optional [ List ] = None ) -> None : \"Write TEMPLATES in `.json` format to `output`.\" output = Path ( output ) output . mkdir ( exist_ok = True ) if targets : templates = [ template for template in TEMPLATES if template . DEFAULT_NAME in targets ] else : templates = TEMPLATES for template_cls in templates : template = template_cls () path = output / template . filename if path . exists (): content = path . read_text ( encoding = \"utf-8\" ) if content != template . content : raise TemplateContentDoesNotMatch ( template . DEFAULT_NAME or \"\" , path ) else : path . write_text ( template . content , encoding = \"utf-8\" )","title":"dump_templates()"},{"location":"reference/dvc_render/vega_templates/#dvc_render.vega_templates.get_template","text":"Return template instance based on given template arg. If template is already an instance, return it. If template is None, return default linear template. If template is a path, will try to find it as absolute path or inside template_dir. If template matches one of the DEFAULT_NAMEs in TEMPLATES, return an instance of the one matching. Source code in dvc_render/vega_templates.py 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 def get_template ( template : Union [ Optional [ str ], Template ] = None , template_dir : Optional [ str ] = None , ) -> Template : \"\"\"Return template instance based on given template arg. If template is already an instance, return it. If template is None, return default `linear` template. If template is a path, will try to find it as absolute path or inside template_dir. If template matches one of the DEFAULT_NAMEs in TEMPLATES, return an instance of the one matching. \"\"\" if isinstance ( template , Template ): return template if template is None : template = \"linear\" template_path = _find_template ( template , template_dir ) if template_path : with open ( template_path , \"r\" , encoding = \"utf-8\" ) as f : content = f . read () return Template ( content , name = template ) for template_cls in TEMPLATES : if template_cls . DEFAULT_NAME == template : return template_cls () raise TemplateNotFoundError ( template )","title":"get_template()"}]}